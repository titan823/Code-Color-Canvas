
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Color Canvas - ライブWebエディタ</title>

    <!-- CodeMirror（CDN） -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/material-darker.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>

    <style>
        /* 全体 */
        :root {
            --bg: #1e1e1e;
            --panel: #252526;
            --panel-2: #2d2d2d;
            --panel-3: #333;
            --border-1: #444;
            --accent: #007acc;
            --text: #d4d4d4;
            --muted: #aaaaaa;
            --ok: #7bd88f;
            --ng: #f26d6d;
            --shadow: rgba(0,0,0,0.35);
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            background-color: var(--panel-3);
            padding: 10px 20px;
            font-size: 1.2em;
            font-weight: bold;
            border-bottom: 2px solid var(--accent);
        }

        /* 上位タブ（編集 / プレビュー / 画像カラー分析） */
        .main-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }
        .top-tabs {
            display: flex;
            background-color: var(--bg);
            border-bottom: 2px solid var(--border-1);
        }
        .top-tab-button {
            padding: 10px 16px;
            border: none;
            background-color: var(--panel-2);
            color: #ccc;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .top-tab-button + .top-tab-button {
            border-left: 1px solid var(--border-1);
        }
        .top-tab-button.active {
            background-color: var(--panel-3);
            color: white;
            border-bottom: 3px solid var(--accent);
        }

        .page-container {
            position: relative;
            flex: 1;
            min-height: 0;
        }
        .tab-page {
            position: absolute;
            inset: 0;
            display: none;
        }
        .tab-page.active {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        /* パネル共通 */
        .panel-header {
            background-color: var(--panel-3);
            padding: 8px 12px;
            font-weight: bold;
            border-bottom: 1px solid var(--border-1);
        }
        .panel {
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
        }

        /* コードエディタ */
        .code-tabs {
            display: flex;
            background-color: var(--bg);
            border-bottom: 1px solid var(--border-1);
        }
        .tab-button {
            padding: 10px 15px;
            border: none;
            background-color: var(--panel-2);
            color: #ccc;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .tab-button.active {
            background-color: var(--panel-3);
            color: white;
            border-bottom: 3px solid var(--accent);
        }
        .editor-container {
            flex: 1;
            position: relative;
            min-height: 0;
        }
        .CodeMirror {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100% !important;
            font-size: 14px;
        }
        .editor-wrapper {
            display: none;
            height: 100%;
        }
        .editor-wrapper.active {
            display: block;
        }

        /* プレビュー・変更（左右分割） */
        .split-container {
            display: flex;
            flex: 1;
            min-height: 0;
        }
        .split-left, .split-right {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .split-left {
            flex: 1 1 55%;
            border-right: 2px solid var(--border-1);
            min-width: 320px;
        }
        .split-right {
            flex: 1 1 45%;
            min-width: 320px;
        }
        .frame-wrap {
            flex: 1;
            min-height: 0;
        }
        #preview-frame {
            width: 100%;
            height: 100%;
            border: none;
            background-color: #fff;
        }

        /* インスペクター（プレビュー・変更タブ右側） */
        .inspector-body {
            flex: 1;
            background-color: var(--panel);
            padding: 15px;
            overflow-y: auto;
        }
        .inspector-item {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .inspector-item label {
            min-width: 120px;
            font-size: 0.9em;
            color: var(--muted);
        }
        .inspector-item input[type="text"],
        .inspector-item textarea {
            background-color: #3c3c3c;
            border: 1px solid #555;
            color: #f0f0f0;
            padding: 6px 8px;
            border-radius: 3px;
            flex: 1 1 240px;
        }
        .inspector-item textarea {
            min-height: 60px;
            resize: vertical;
        }
        .color-swatch {
            width: 18px;
            height: 18px;
            border: 1px solid #555;
            border-radius: 3px;
            background: transparent;
        }
        .validity-badge {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
            border: 1px solid #555;
            color: #ddd;
        }
        .validity-badge.ok { border-color: #2e7d32; color: var(--ok); }
        .validity-badge.ng { border-color: #8e2a2a; color: var(--ng); }
        .inspector-actions { display: inline-flex; gap: 6px; align-items: center; }
        .btn {
            background: var(--panel-2);
            border: 1px solid #555;
            color: #eee;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        .btn:hover { background: #3a3a3a; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn.active { background: #3a4a5a; border-color: var(--accent); color: #fff; }

        /* 画像カラー分析タブ */
        .img-toolbar {
            display: flex; gap: 8px; align-items: center;
            padding: 8px 12px; background: var(--panel-2); border-bottom: 1px solid var(--border-1);
            flex-wrap: wrap;
        }
        .img-toolbar input[type="text"] {
            background: #3c3c3c; border: 1px solid #555; color: #f0f0f0; padding: 6px 8px; border-radius: 3px;
            min-width: 200px; flex: 1 1 200px;
        }
        .img-toolbar input[type="file"] { color: #ddd; }
        .img-toolbar .field {
            display: inline-flex; align-items: center; gap: 6px; color: #ddd;
        }
        .img-toolbar .field input[type="number"], .img-toolbar .field input[type="range"] {
            background: #3c3c3c; border: 1px solid #555; color: #f0f0f0; padding: 3px 6px; border-radius: 3px;
        }
        .img-switcher {
            display: flex; gap: 6px; align-items: center; flex-wrap: wrap;
            padding: 8px 12px; background: var(--panel-2); border-bottom: 1px solid var(--border-1);
        }
        .img-chip {
            padding: 4px 10px; border: 1px solid #555; border-radius: 16px; background: #2f2f2f; color: #ddd; cursor: pointer;
        }
        .img-chip.active {
            background: var(--accent); border-color: var(--accent); color: #fff;
        }
        .img-stage {
            position: relative; flex: 1; min-height: 0;
            /* チェッカーボード */
            background: conic-gradient(#eee 25%, #fff 0 50%, #eee 0 75%, #fff 0) 0 0 / 16px 16px;
            overflow: hidden;
        }
        #image-canvas {
            width: 100%; height: 100%; display: block; background: transparent;
        }
        #magnifier-canvas {
            position: absolute; width: 140px; height: 140px;
            border: 1px solid #666; border-radius: 6px; box-shadow: 0 6px 18px var(--shadow);
            display: none; pointer-events: none; background: #111; z-index: 5;
        }
        .img-stage.picking #image-canvas { cursor: crosshair; }
        .stage-hint {
            position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
            color: #ccc; font-size: 0.95em; text-align: center; padding: 8px; pointer-events: none; z-index: 1;
        }
        .stage-overlay {
            position: absolute; inset: 0; border: 2px dashed #666; border-radius: 8px; pointer-events: none; margin: 8px; z-index: 2;
        }
        .touch-marker {
            position: absolute; width: 14px; height: 14px; border: 2px solid #40a0ff; border-radius: 50%;
            background: rgba(64,160,255,0.2); transform: translate(-50%,-50%); display: none; z-index: 6;
        }
        .offset-line {
            position: absolute; width: 2px; background: rgba(64,160,255,0.85); border-radius: 1px;
            display: none; z-index: 4;
        }
        .brush-cursor {
            position: absolute; border: 1.5px dashed #4af; border-radius: 50%;
            transform: translate(-50%,-50%); pointer-events: none; display: none; z-index: 5;
        }
        .panel-section-title { font-weight: bold; margin: 12px 0 6px; color: #fff; }
        .current-color { display: flex; align-items: center; gap: 10px; }
        .swatch-large { width: 64px; height: 64px; border: 1px solid #555; border-radius: 6px; background: #000; }
        .kv-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; flex-wrap: wrap; }
        .kv-row code {
            background: #2a2a2a; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; color: #eee; word-break: break-all;
        }
        .copy-btn { padding: 4px 8px; }
        .contrast-box { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 6px; }
        .contrast-sample { height: 48px; display: flex; align-items: center; justify-content: center; border-radius: 6px; border: 1px solid #555; font-weight: 600; }
        .history-list { display: flex; flex-wrap: wrap; gap: 8px; }
        .history-item { width: 28px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer; }
        .status-line { font-size: 0.85em; color: #ccc; padding: 4px 12px; border-top: 1px solid #444; background: #2b2b2b; }
        .note { color: #bbb; font-size: 0.85em; }
    </style>
</head>
<body>
    <header>Code Color Canvas</header>

    <main class="main-container">
        <!-- 上位タブ -->
        <div class="top-tabs">
            <button class="top-tab-button active" onclick="showMainTab('code')">コード編集</button>
            <button class="top-tab-button" onclick="showMainTab('preview')">プレビュー・変更</button>
            <button class="top-tab-button" onclick="showMainTab('image')">画像カラー分析</button>
        </div>

        <div class="page-container">
            <!-- コード編集タブ -->
            <section id="code-page" class="tab-page active">
                <div class="panel code-panel">
                    <div class="panel-header">コード編集</div>
                    <div class="code-tabs">
                        <button class="tab-button active" onclick="showEditor('html')">HTML</button>
                        <button class="tab-button" onclick="showEditor('css')">CSS</button>
                        <button class="tab-button" onclick="showEditor('js')">JavaScript</button>
                    </div>
                    <div class="editor-container">
                        <div id="html-editor-wrapper" class="editor-wrapper active">
                            <textarea id="html-code"></textarea>
                        </div>
                        <div id="css-editor-wrapper" class="editor-wrapper">
                            <textarea id="css-code"></textarea>
                        </div>
                        <div id="js-editor-wrapper" class="editor-wrapper">
                            <textarea id="js-code"></textarea>
                        </div>
                    </div>
                </div>
            </section>

            <!-- プレビュー・変更タブ（左右分割） -->
            <section id="preview-page" class="tab-page">
                <div class="split-container">
                    <div class="split-left">
                        <div class="panel-header">プレビュー</div>
                        <div class="frame-wrap">
                            <iframe id="preview-frame"></iframe>
                        </div>
                    </div>
                    <div class="split-right">
                        <div class="panel-header">インスペクター</div>
                        <div class="inspector-body">
                            <p id="inspector-placeholder">プレビュー内の要素をクリックすると、ここでテキストやスタイルを編集できます。</p>
                            <div id="inspector-ui" style="display: none;">
                                <div class="inspector-item">
                                    <label>選択中の要素</label>
                                    <b id="selected-element-selector"></b>
                                </div>

                                <!-- テキスト編集 -->
                                <div class="inspector-item">
                                    <label for="inspector-text">テキスト</label>
                                    <textarea id="inspector-text" placeholder="選択した要素のテキストを編集"></textarea>
                                    <div class="inspector-actions">
                                        <label style="display:inline-flex; align-items:center; gap:6px; color:#ccc; font-size: 0.9em;">
                                            <input type="checkbox" id="inspector-text-as-html"> HTMLとして編集
                                        </label>
                                        <button class="btn" id="apply-text">適用</button>
                                    </div>
                                </div>

                                <!-- テキスト色 -->
                                <div class="inspector-item">
                                    <label for="inspector-color">テキスト色</label>
                                    <input type="text" id="inspector-color" placeholder="例: #ff8800, rgb(255 136 0 / 80%), hsl(30 100% 50%), rebeccapurple, color(display-p3 1 0.5 0)">
                                    <span class="color-swatch" id="swatch-color"></span>
                                    <span class="validity-badge" id="valid-color">未入力</span>
                                    <div class="inspector-actions">
                                        <button class="btn" id="apply-color" disabled>適用</button>
                                        <button class="btn" id="undo-color" disabled>元に戻す</button>
                                        <button class="btn" id="redo-color" disabled>やり直す</button>
                                    </div>
                                </div>

                                <!-- 背景色 -->
                                <div class="inspector-item">
                                    <label for="inspector-bg">背景色</label>
                                    <input type="text" id="inspector-bg" placeholder="例: transparent, #222, rgba(0 0 0 / .4), lch(50 60 40)">
                                    <span class="color-swatch" id="swatch-bg"></span>
                                    <span class="validity-badge" id="valid-bg">未入力</span>
                                    <div class="inspector-actions">
                                        <button class="btn" id="apply-bg" disabled>適用</button>
                                        <button class="btn" id="undo-bg" disabled>元に戻す</button>
                                        <button class="btn" id="redo-bg" disabled>やり直す</button>
                                    </div>
                                </div>

                                <!-- ボックス系 -->
                                <div class="inspector-item">
                                    <label for="inspector-padding">パディング</label>
                                    <input type="text" id="inspector-padding" placeholder="例: 10px / 8px 12px / 1rem 2rem">
                                </div>
                                <div class="inspector-item">
                                    <label for="inspector-margin">マージン</label>
                                    <input type="text" id="inspector-margin" placeholder="例: 10px auto / 0 16px">
                                </div>
                                <div class="inspector-item">
                                    <label for="inspector-fontSize">フォントサイズ</label>
                                    <input type="text" id="inspector-fontSize" placeholder="例: 16px / 1.2rem / clamp(14px, 2vw, 20px)">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 画像カラー分析タブ（左右分割） -->
            <section id="image-page" class="tab-page">
                <div class="split-container">
                    <!-- 左：画像 -->
                    <div class="split-left">
                        <div class="panel-header">画像</div>
                        <div class="img-toolbar">
                            <input type="file" id="img-file" accept="image/*" multiple>
                            <input type="text" id="img-url" placeholder="画像URL（CORS対応のもの）">
                            <button class="btn" id="btn-load-url">読み込み</button>

                            <button class="btn" id="btn-eyedropper" title="対応ブラウザのみ">画面スポイト</button>

                            <button class="btn" id="btn-canvas-picker" title="キャンバス上で色を取得">キャンバススポイト</button>
                            <button class="btn" id="btn-blur" title="キャンバス上でボカシをかける">ボカシブラシ</button>

                            <span class="field">
                                サイズ <input type="range" id="brush-radius" min="4" max="200" value="24">
                                <span id="brush-radius-val">24px</span>
                            </span>
                            <span class="field">
                                強度 <input type="range" id="brush-strength" min="1" max="20" value="6">
                                <span id="brush-strength-val">6px</span>
                            </span>

                            <span class="field">
                                <label style="display:inline-flex;align-items:center;gap:6px;">
                                    <input type="checkbox" id="touch-offset-enabled" checked> タッチ補正
                                </label>
                                上へ <input type="number" id="touch-offset-value" value="40" step="1" min="-200" max="200" style="width:80px;"> px
                            </span>

                            <span class="note">最大10枚を番号で切替</span>
                        </div>

                        <div class="img-switcher" id="img-switcher"></div>

                        <div class="img-stage" id="image-stage">
                            <canvas id="image-canvas"></canvas>
                            <canvas id="magnifier-canvas" width="140" height="140"></canvas>

                            <!-- オーバーレイ（マーカー類） -->
                            <div id="touch-marker" class="touch-marker"></div>
                            <div id="offset-line" class="offset-line"></div>
                            <div id="brush-cursor" class="brush-cursor"></div>

                            <div class="stage-hint" id="stage-hint">画像を読み込むか、ここにドラッグ＆ドロップしてください（複数可）</div>
                            <div class="stage-overlay" id="stage-overlay" style="display:none;"></div>
                        </div>
                        <div class="status-line" id="img-status"></div>
                    </div>

                    <!-- 右：分析結果 -->
                    <div class="split-right">
                        <div class="panel-header">カラー分析</div>
                        <div class="inspector-body" id="image-inspector">
                            <div class="panel-section-title">現在の色</div>
                            <div class="current-color">
                                <div class="swatch-large" id="current-swatch"></div>
                                <div id="current-color-text">未取得</div>
                            </div>

                            <div class="panel-section-title">表記</div>
                            <div class="kv-row"><label style="min-width:80px;">HEX</label><code id="hex-val">-</code><button class="btn copy-btn" data-copy-target="hex-val">コピー</button></div>
                            <div class="kv-row"><label style="min-width:80px;">HEXA</label><code id="hexa-val">-</code><button class="btn copy-btn" data-copy-target="hexa-val">コピー</button></div>
                            <div class="kv-row"><label style="min-width:80px;">RGB(A)</label><code id="rgb-val">-</code><button class="btn copy-btn" data-copy-target="rgb-val">コピー</button></div>
                            <div class="kv-row"><label style="min-width:80px;">HSL(A)</label><code id="hsl-val">-</code><button class="btn copy-btn" data-copy-target="hsl-val">コピー</button></div>

                            <div class="panel-section-title">視認性</div>
                            <div class="kv-row"><label style="min-width:120px;">相対輝度</label><code id="luminance-val">-</code></div>
                            <div class="kv-row"><label style="min-width:120px;">コントラスト比</label>
                                <div>対黒: <code id="contrast-black">-</code></div>
                                <div>対白: <code id="contrast-white">-</code></div>
                            </div>
                            <div class="contrast-box">
                                <div class="contrast-sample" id="contrast-on-black" style="background:#000;color:#fff;">サンプル</div>
                                <div class="contrast-sample" id="contrast-on-white" style="background:#fff;color:#000;">サンプル</div>
                            </div>

                            <div class="panel-section-title">履歴（画像ごとに保存）</div>
                            <div class="history-list" id="history-list"></div>
                            <p class="note">画面スポイトはChrome/Edgeなどで使用可能です。URL読み込みはCORS対応の画像のみキャンバス内スポイトが動作します（ローカルファイルはOK）。</p>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- グローバル（プレビュー・変更タブ関連） ---
            let selectedElement = null;
            let lastHighlightedElement = null;
            let lastSelectedSelectorPath = null;

            // 色の履歴（セレクタごと／プロパティごと）: Undo/Redo スタック
            const colorHistory = new Map();
            function getHistory(selector) {
                if (!colorHistory.has(selector)) {
                    colorHistory.set(selector, {
                        color: { undo: [], redo: [] },
                        backgroundColor: { undo: [], redo: [] }
                    });
                }
                return colorHistory.get(selector);
            }

            // --- CodeMirror 初期化 ---
            const htmlEditor = CodeMirror.fromTextArea(document.getElementById('html-code'), {
                mode: 'xml',
                htmlMode: true,
                theme: 'material-darker',
                lineNumbers: true,
            });
            const cssEditor = CodeMirror.fromTextArea(document.getElementById('css-code'), {
                mode: 'css',
                theme: 'material-darker',
                lineNumbers: true,
            });
            const jsEditor = CodeMirror.fromTextArea(document.getElementById('js-code'), {
                mode: 'javascript',
                theme: 'material-darker',
                lineNumbers: true,
            });

            // --- 初期コード ---
            const initialHTML = `<div class="container">
  <h1 id="main-title">Code Color Canvasへようこそ！</h1>
  <p>ここにあるテキストやスタイルを自由に編集できます。</p>
  <button id="action-btn">クリック</button>
</div>`;
            const initialCSS = `/* ページ全体のスタイル */
html, body { height: 100%; }
body {
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
  background-color: #f0f0f0;
  display: flex; justify-content: center; align-items: center; margin: 0;
}
.container {
  text-align: center; padding: 40px; background-color: white; border-radius: 12px;
  box-shadow: 0 6px 16px rgba(0,0,0,0.12);
}
#main-title { color: #333; margin: 0 0 10px 0; }
#action-btn {
  background-color: #007acc; color: white; border: none; padding: 10px 20px; border-radius: 8px;
  cursor: pointer; font-size: 16px;
}`;
            const initialJS = `document.getElementById('action-btn')?.addEventListener('click', () => {
  alert('ボタンがクリックされました！');
});`;

            htmlEditor.setValue(initialHTML);
            cssEditor.setValue(initialCSS);
            jsEditor.setValue(initialJS);

            // --- 上位タブ切替 ---
            window.showMainTab = function(name) {
                document.querySelectorAll('.top-tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-page').forEach(p => p.classList.remove('active'));
                document.querySelector(\`.top-tab-button[onclick="showMainTab('\${name}')"]\`).classList.add('active');
                document.getElementById(name === 'code' ? 'code-page' : name === 'preview' ? 'preview-page' : 'image-page').classList.add('active');

                if (name === 'code') {
                    htmlEditor.refresh(); cssEditor.refresh(); jsEditor.refresh();
                } else if (name === 'image') {
                    if (typeof resizeImageStage === 'function') resizeImageStage();
                }
            };

            // --- サブタブ（HTML/CSS/JS） ---
            window.showEditor = function(editorName) {
                document.querySelectorAll('.editor-wrapper').forEach(w => w.classList.remove('active'));
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                document.getElementById(\`\${editorName}-editor-wrapper\`).classList.add('active');
                document.querySelector(\`.tab-button[onclick="showEditor('\${editorName}')"]\`).classList.add('active');
                if (editorName === 'html') htmlEditor.refresh();
                if (editorName === 'css') cssEditor.refresh();
                if (editorName === 'js') jsEditor.refresh();
            };

            // --- プレビュー更新 ---
            function updatePreview() {
                const iframe = document.getElementById('preview-frame');
                const doc = iframe.contentDocument || iframe.contentWindow.document;

                const htmlCode = htmlEditor.getValue();
                const cssCode = cssEditor.getValue();
                const jsCode = jsEditor.getValue();

                doc.open();
                doc.write(`<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>${cssCode}</style>
</head>
<body>
${htmlCode}
<script>(function(){\n${jsCode}\n})();<\/script>
</body>
</html>`);
                doc.close();

                setupInspectorListeners();
                if (!restoreSelection()) {
                    selectedElement = null;
                    lastHighlightedElement = null;
                    showInspectorPlaceholder();
                }
            }
            htmlEditor.on('change', updatePreview);
            cssEditor.on('change', updatePreview);
            jsEditor.on('change', updatePreview);

            // --- インスペクター（プレビュー・変更） ---
            function setupInspectorListeners() {
                const iframe = document.getElementById('preview-frame');
                const pdoc = iframe.contentDocument || iframe.contentWindow.document;
                const pbody = pdoc && pdoc.body;
                if (!pbody) return;
                pbody.addEventListener('click', (e) => {
                    e.preventDefault(); e.stopPropagation();
                    if (lastHighlightedElement) lastHighlightedElement.style.outline = '';
                    selectedElement = e.target;
                    selectedElement.style.outline = '2px solid #007acc';
                    lastHighlightedElement = selectedElement;
                    lastSelectedSelectorPath = getCssSelector(selectedElement);
                    populateInspector(selectedElement);
                }, { capture: true });
            }
            function restoreSelection() {
                if (!lastSelectedSelectorPath) return false;
                const iframe = document.getElementById('preview-frame');
                const pdoc = iframe.contentDocument || iframe.contentWindow.document;
                if (!pdoc) return false;
                let el = null; try { el = pdoc.querySelector(lastSelectedSelectorPath); } catch (_) {}
                if (el) {
                    if (lastHighlightedElement) lastHighlightedElement.style.outline = '';
                    selectedElement = el;
                    selectedElement.style.outline = '2px solid #007acc';
                    lastHighlightedElement = selectedElement;
                    populateInspector(selectedElement);
                    return true;
                }
                return false;
            }
            function getCssSelector(el) {
                if (!el || el.nodeType !== 1) return '';
                const parts = [];
                while (el && el.nodeType === 1) {
                    let selector = el.nodeName.toLowerCase();
                    if (el.id) {
                        selector = '#' + el.id; parts.unshift(selector); break;
                    } else {
                        if (el.classList && el.classList.length) selector += '.' + el.classList[0];
                        let sib = el, nth = 1;
                        while (sib = sib.previousElementSibling) {
                            if (sib.nodeName.toLowerCase() === el.nodeName.toLowerCase()) nth++;
                        }
                        if (nth !== 1) selector += \`:nth-of-type(\${nth})\`;
                    }
                    parts.unshift(selector);
                    el = el.parentNode;
                }
                return parts.join(' > ');
            }
            function showInspectorPlaceholder() {
                document.getElementById('inspector-placeholder').style.display = 'block';
                document.getElementById('inspector-ui').style.display = 'none';
            }
            function populateInspector(element) {
                document.getElementById('inspector-placeholder').style.display = 'none';
                document.getElementById('inspector-ui').style.display = 'block';
                const iframe = document.getElementById('preview-frame');
                const pwin = iframe.contentWindow;
                const styles = pwin.getComputedStyle(element);
                document.getElementById('selected-element-selector').textContent = getCssSelector(element);
                const textAsHTML = document.getElementById('inspector-text-as-html');
                textAsHTML.checked = false;
                document.getElementById('inspector-text').value = element.textContent ?? '';
                const colorInput = document.getElementById('inspector-color');
                const bgInput = document.getElementById('inspector-bg');
                colorInput.value = styles.color || '';
                bgInput.value = styles.backgroundColor || '';
                updateColorUI('color'); updateColorUI('bg'); updateApplyButtons(); updateHistoryButtons();
                document.getElementById('inspector-padding').value = styles.padding || '';
                document.getElementById('inspector-margin').value = styles.margin || '';
                document.getElementById('inspector-fontSize').value = styles.fontSize || '';
            }

            function applyStyleChange(property, value) {
                if (!selectedElement) return;
                selectedElement.style[property] = value;
                const selector = getCssSelector(selectedElement);
                let cssCode = cssEditor.getValue();
                const cssProperty = property.replace(/([A-Z])/g, '-$1').toLowerCase();
                const esc = selector.replace(/[\/\\^$*+?.()|[\]{}]/g, '\\$&');
                const regex = new RegExp(\`(\${esc})\\s*\\{([^}]*)\\}\`, 's');
                const match = cssCode.match(regex);
                if (match) {
                    let properties = match[2];
                    const propRegex = new RegExp(\`(^|;)\\s*\${cssProperty}\\s*:[^;]*\`, 'i');
                    if (propRegex.test(properties)) {
                        const newProperties = properties.replace(propRegex, \`$1 \${cssProperty}: \${value}\`);
                        cssCode = cssCode.replace(match[0], \`\${selector} {\${newProperties}}\`);
                    } else {
                        const trimmed = properties.trim();
                        const sep = trimmed && !trimmed.endsWith(';') ? ';' : '';
                        const newProperties = \`\${trimmed}\${sep} \${cssProperty}: \${value}; \`;
                        cssCode = cssCode.replace(match[0], \`\${selector} {\\n\${newProperties}\\n}\`);
                    }
                } else {
                    cssCode += \`\\n\\n\${selector} {\\n    \${cssProperty}: \${value};\\n}\`;
                }
                lastSelectedSelectorPath = selector;
                cssEditor.setValue(cssCode);
            }

            // カラー入力 妥当性
            function isValidCSSColor(value) {
                const iframe = document.getElementById('preview-frame');
                const pwin = iframe.contentWindow;
                try {
                    if (pwin.CSS && typeof pwin.CSS.supports === 'function') {
                        return pwin.CSS.supports('color', value);
                    }
                } catch (_) { }
                const opt = pwin.document.createElement('option');
                opt.style.color = '';
                opt.style.color = value;
                return !!opt.style.color;
            }
            function updateColorUI(kind) {
                const input = document.getElementById(kind === 'color' ? 'inspector-color' : 'inspector-bg');
                const swatch = document.getElementById(kind === 'color' ? 'swatch-color' : 'swatch-bg');
                const badge = document.getElementById(kind === 'color' ? 'valid-color' : 'valid-bg');
                const val = input.value.trim();
                if (!val) { swatch.style.background = 'transparent'; badge.textContent = '未入力'; badge.classList.remove('ok','ng'); }
                else if (isValidCSSColor(val)) { swatch.style.background = val; badge.textContent = 'OK'; badge.classList.add('ok'); badge.classList.remove('ng'); }
                else { swatch.style.background = 'transparent'; badge.textContent = '不正'; badge.classList.add('ng'); badge.classList.remove('ok'); }
                updateApplyButtons();
            }
            function updateApplyButtons() {
                const colorVal = document.getElementById('inspector-color').value.trim();
                const bgVal = document.getElementById('inspector-bg').value.trim();
                document.getElementById('apply-color').disabled = !(selectedElement && isValidCSSColor(colorVal));
                document.getElementById('apply-bg').disabled = !(selectedElement && isValidCSSColor(bgVal));
            }
            function updateHistoryButtons() {
                const selector = lastSelectedSelectorPath;
                const entry = selector ? colorHistory.get(selector) : null;
                const canUndoColor = !!(entry && entry.color.undo.length);
                const canUndoBg = !!(entry && entry.backgroundColor.undo.length);
                const canRedoColor = !!(entry && entry.color.redo.length);
                const canRedoBg = !!(entry && entry.backgroundColor.redo.length);
                document.getElementById('undo-color').disabled = !canUndoColor;
                document.getElementById('undo-bg').disabled = !canUndoBg;
                document.getElementById('redo-color').disabled = !canRedoColor;
                document.getElementById('redo-bg').disabled = !canRedoBg;
            }

            document.getElementById('inspector-color').addEventListener('input', () => updateColorUI('color'));
            document.getElementById('inspector-bg').addEventListener('input', () => updateColorUI('bg'));
            document.getElementById('apply-color').addEventListener('click', () => commitColor('color'));
            document.getElementById('apply-bg').addEventListener('click', () => commitColor('backgroundColor'));
            document.getElementById('undo-color').addEventListener('click', () => undoColor('color'));
            document.getElementById('undo-bg').addEventListener('click', () => undoColor('backgroundColor'));
            document.getElementById('redo-color').addEventListener('click', () => redoColor('color'));
            document.getElementById('redo-bg').addEventListener('click', () => redoColor('backgroundColor'));

            function commitColor(prop) {
                if (!selectedElement) return;
                const input = document.getElementById(prop === 'color' ? 'inspector-color' : 'inspector-bg');
                const val = input.value.trim();
                if (!isValidCSSColor(val)) return;
                const selector = getCssSelector(selectedElement);
                lastSelectedSelectorPath = selector;
                const iframe = document.getElementById('preview-frame');
                const pwin = iframe.contentWindow;
                const styles = pwin.getComputedStyle(selectedElement);
                const prev = prop === 'color' ? styles.color : styles.backgroundColor;
                const h = getHistory(selector);
                h[prop].undo.push(prev);
                h[prop].redo.length = 0;
                updateHistoryButtons();
                applyStyleChange(prop, val);
            }
            function undoColor(prop) {
                const selector = lastSelectedSelectorPath;
                if (!selector) return;
                const h = colorHistory.get(selector);
                if (!h || !h[prop] || !h[prop].undo.length) return;
                const iframe = document.getElementById('preview-frame');
                const pwin = iframe.contentWindow;
                const styles = pwin.getComputedStyle(selectedElement);
                const currentVal = prop === 'color' ? styles.color : styles.backgroundColor;
                h[prop].redo.push(currentVal);
                const prev = h[prop].undo.pop();
                const input = document.getElementById(prop === 'color' ? 'inspector-color' : 'inspector-bg');
                input.value = prev || '';
                updateColorUI(prop === 'color' ? 'color' : 'bg');
                applyStyleChange(prop, prev);
                updateHistoryButtons();
            }
            function redoColor(prop) {
                const selector = lastSelectedSelectorPath;
                if (!selector) return;
                const h = colorHistory.get(selector);
                if (!h || !h[prop] || !h[prop].redo.length) return;
                const iframe = document.getElementById('preview-frame');
                const pwin = iframe.contentWindow;
                const styles = pwin.getComputedStyle(selectedElement);
                const currentVal = prop === 'color' ? styles.color : styles.backgroundColor;
                h[prop].undo.push(currentVal);
                const nextVal = h[prop].redo.pop();
                const input = document.getElementById(prop === 'color' ? 'inspector-color' : 'inspector-bg');
                input.value = nextVal || '';
                updateColorUI(prop === 'color' ? 'color' : 'bg');
                applyStyleChange(prop, nextVal);
                updateHistoryButtons();
            }

            // テキスト編集
            const textArea = document.getElementById('inspector-text');
            const textAsHTML = document.getElementById('inspector-text-as-html');
            const applyTextBtn = document.getElementById('apply-text');
            textAsHTML.addEventListener('change', () => {
                if (!selectedElement) return;
                textArea.value = textAsHTML.checked ? (selectedElement.innerHTML ?? '') : (selectedElement.textContent ?? '');
            });
            function toBodyRelativeSelector(sel) {
                return sel.replace(/^html\s*>\s*body\s*>\s*/i, '').replace(/^body\s*>\s*/i, '');
            }
            applyTextBtn.addEventListener('click', () => {
                if (!selectedElement) return;
                const selector = getCssSelector(selectedElement);
                lastSelectedSelectorPath = selector;
                const value = textArea.value ?? '';
                if (textAsHTML.checked) selectedElement.innerHTML = value; else selectedElement.textContent = value;
                const wrapper = document.createElement('div');
                wrapper.innerHTML = htmlEditor.getValue();
                let target = null;
                try { target = wrapper.querySelector(selector); } catch (_) {}
                if (!target) {
                    const rel = toBodyRelativeSelector(selector);
                    try { target = wrapper.querySelector(rel); } catch (_) {}
                }
                if (!target && selectedElement.id) {
                    try { target = wrapper.querySelector('#' + selectedElement.id); } catch (_) {}
                }
                if (target) {
                    if (textAsHTML.checked) target.innerHTML = value; else target.textContent = value;
                    htmlEditor.setValue(wrapper.innerHTML.trim());
                }
            });

            // --- 初期プレビュー描画 ---
            updatePreview();
            showMainTab('code');

            // =========================
            // 画像カラー分析タブ（複数画像＋スポイト＋ボカシ＋タッチ補正）
            // =========================
            const MAX_IMAGES = 10;
            let images = []; // { id, img, sourceCanvas, sctx, drawnRect:{dx,dy,dw,dh,scale}, history:[], currentColor:null }
            let activeIndex = -1;

            const stage = document.getElementById('image-stage');
            const displayCanvas = document.getElementById('image-canvas');
            const dctx = displayCanvas.getContext('2d');
            const magnifierCanvas = document.getElementById('magnifier-canvas');
            const mctx = magnifierCanvas.getContext('2d');
            mctx.imageSmoothingEnabled = false;

            const touchMarker = document.getElementById('touch-marker');
            const offsetLine = document.getElementById('offset-line');
            const brushCursor = document.getElementById('brush-cursor');

            const statusLine = document.getElementById('img-status');
            const stageHint = document.getElementById('stage-hint');
            const stageOverlay = document.getElementById('stage-overlay');
            const switcher = document.getElementById('img-switcher');

            const fileInput = document.getElementById('img-file');
            const urlInput = document.getElementById('img-url');
            const urlBtn = document.getElementById('btn-load-url');
            const eyedropBtn = document.getElementById('btn-eyedropper');
            const canvasPickerBtn = document.getElementById('btn-canvas-picker');
            const blurBtn = document.getElementById('btn-blur');

            const brushRadiusInput = document.getElementById('brush-radius');
            const brushRadiusVal = document.getElementById('brush-radius-val');
            const brushStrengthInput = document.getElementById('brush-strength');
            const brushStrengthVal = document.getElementById('brush-strength-val');

            const touchOffsetEnabled = document.getElementById('touch-offset-enabled');
            const touchOffsetValue = document.getElementById('touch-offset-value');

            let tool = null; // 'picker' | 'blur' | null
            let isDrawing = false; // blur描画中
            let activePointerId = null;

            const historyContainer = document.getElementById('history-list');
            const currentSwatch = document.getElementById('current-swatch');
            const currentColorText = document.getElementById('current-color-text');

            const outHex = document.getElementById('hex-val');
            const outHexa = document.getElementById('hexa-val');
            const outRgb = document.getElementById('rgb-val');
            const outHsl = document.getElementById('hsl-val');
            const outLum = document.getElementById('luminance-val');
            const outContB = document.getElementById('contrast-black');
            const outContW = document.getElementById('contrast-white');
            const sampleOnBlack = document.getElementById('contrast-on-black');
            const sampleOnWhite = document.getElementById('contrast-on-white');

            // 一時キャンバス（ボカシ処理用）
            const tmpCanvas = document.createElement('canvas');
            const tmpCtx = tmpCanvas.getContext('2d');
            const tmpBlurCanvas = document.createElement('canvas');
            const tmpBlurCtx = tmpBlurCanvas.getContext('2d');

            let needsRedraw = false;
            let rafId = 0;
            function scheduleRedraw() {
                if (rafId) return;
                rafId = requestAnimationFrame(() => {
                    redrawDisplay();
                    rafId = 0;
                });
            }

            function setStatus(msg) { statusLine.textContent = msg || ''; }

            function enableEyedropperUI() {
                if (!('EyeDropper' in window)) {
                    eyedropBtn.disabled = true;
                    eyedropBtn.title = 'このブラウザは画面スポイトに未対応です';
                }
            }
            enableEyedropperUI();

            function addImageFromHTMLImageElement(img) {
                if (images.length >= MAX_IMAGES) {
                    setStatus(`これ以上追加できません（最大${MAX_IMAGES}枚）`);
                    return;
                }
                const sourceCanvas = document.createElement('canvas');
                const sctx = sourceCanvas.getContext('2d', { willReadFrequently: true });
                sctx.imageSmoothingEnabled = false;
                const iw = img.naturalWidth || img.width;
                const ih = img.naturalHeight || img.height;
                sourceCanvas.width = iw;
                sourceCanvas.height = ih;
                sctx.clearRect(0,0,iw,ih);
                sctx.drawImage(img, 0, 0);

                const id = images.length + 1;
                const item = { id, img, sourceCanvas, sctx, drawnRect: {dx:0,dy:0,dw:0,dh:0,scale:1}, history: [], currentColor: null };
                images.push(item);
                renderImageButtons();
                setActiveImage(images.length - 1);
                setStatus(`画像${id} を追加しました（${iw}×${ih}）`);
            }

            function renderImageButtons() {
                switcher.innerHTML = '';
                images.forEach((it, i) => {
                    const btn = document.createElement('button');
                    btn.className = 'img-chip' + (i === activeIndex ? ' active' : '');
                    btn.textContent = `画像${it.id}`;
                    btn.addEventListener('click', () => setActiveImage(i));
                    switcher.appendChild(btn);
                });
            }

            function setActiveImage(index) {
                if (index < 0 || index >= images.length) return;
                activeIndex = index;
                renderImageButtons();
                stageHint.style.display = 'none';
                resizeImageStage();
                const act = getActiveImage();
                if (act && act.currentColor) {
                    setCurrentColor(act.currentColor, false);
                } else {
                    resetColorOutputs();
                }
                renderHistory();
                setStatus(`画像${act.id} を表示中`);
            }

            function getActiveImage() {
                if (activeIndex < 0 || activeIndex >= images.length) return null;
                return images[activeIndex];
            }

            function loadImageFromFile(file) {
                if (!file || !file.type || !file.type.startsWith('image/')) {
                    setStatus('画像ファイルを選択してください');
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    loadImageFromSrc(e.target.result, false);
                };
                reader.readAsDataURL(file);
            }

            function loadImageFromSrc(src, remote) {
                const img = new Image();
                if (remote) img.crossOrigin = 'anonymous';
                img.onload = () => addImageFromHTMLImageElement(img);
                img.onerror = () => setStatus('画像を読み込めませんでした（URLの誤りやCORS制限の可能性があります）');
                img.src = src;
            }

            function resizeImageStage() {
                const rect = stage.getBoundingClientRect();
                const w = Math.max(10, Math.floor(rect.width));
                const h = Math.max(10, Math.floor(rect.height));
                if (displayCanvas.width !== w || displayCanvas.height !== h) {
                    displayCanvas.width = w;
                    displayCanvas.height = h;
                }
                redrawDisplay();
            }
            window.resizeImageStage = resizeImageStage;

            function redrawDisplay() {
                dctx.clearRect(0,0,displayCanvas.width, displayCanvas.height);
                const act = getActiveImage();
                if (!act) return;
                const sc = act.sourceCanvas;
                const iw = sc.width;
                const ih = sc.height;
                const sw = displayCanvas.width;
                const sh = displayCanvas.height;
                const scale = Math.min(sw/iw, sh/ih);
                const dw = Math.max(1, Math.floor(iw * scale));
                const dh = Math.max(1, Math.floor(ih * scale));
                const dx = Math.floor((sw - dw)/2);
                const dy = Math.floor((sh - dh)/2);
                act.drawnRect = { dx, dy, dw, dh, scale };
                dctx.imageSmoothingEnabled = true;
                dctx.drawImage(sc, 0, 0, iw, ih, dx, dy, dw, dh);
            }

            // キャンバス上の座標 -> 元画像のピクセル座標へ変換
            function mapToImagePixel(clientX, clientY) {
                const act = getActiveImage();
                if (!act) return null;
                const rect = displayCanvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                const { dx, dy, dw, dh } = act.drawnRect || {dx:0,dy:0,dw:0,dh:0};
                if (x < dx || y < dy || x >= dx + dw || y >= dy + dh) return null;
                const nx = (x - dx) / dw;
                const ny = (y - dy) / dh;
                const px = Math.max(0, Math.min(act.sourceCanvas.width - 1, Math.floor(nx * act.sourceCanvas.width)));
                const py = Math.max(0, Math.min(act.sourceCanvas.height - 1, Math.floor(ny * act.sourceCanvas.height)));
                return { px, py, cx: x, cy: y };
            }

            function readPixel(px, py) {
                const act = getActiveImage();
                if (!act) return null;
                try {
                    const data = act.sctx.getImageData(px, py, 1, 1).data;
                    return { r: data[0], g: data[1], b: data[2], a: data[3] / 255 };
                } catch (e) {
                    setStatus('キャンバスからの読み取りに失敗しました（CORS制限の可能性）');
                    return null;
                }
            }

            function drawMagnifier(px, py, cx, cy) {
                const act = getActiveImage();
                if (!act) return;
                const w = magnifierCanvas.width;
                const h = magnifierCanvas.height;
                const size = 21; // 21x21ピクセルを拡大
                const half = Math.floor(size / 2);
                const sx = Math.max(0, Math.min(act.sourceCanvas.width - size, px - half));
                const sy = Math.max(0, Math.min(act.sourceCanvas.height - size, py - half));
                mctx.clearRect(0,0,w,h);
                mctx.imageSmoothingEnabled = false;
                mctx.fillStyle = '#222'; mctx.fillRect(0,0,w,h);
                mctx.drawImage(act.sourceCanvas, sx, sy, size, size, 0, 0, w, h);

                // グリッド
                mctx.strokeStyle = 'rgba(255,255,255,0.2)'; mctx.lineWidth = 1;
                const step = w / size;
                for (let i = 1; i < size; i++) {
                    mctx.beginPath(); mctx.moveTo(i*step, 0); mctx.lineTo(i*step, h); mctx.stroke();
                    mctx.beginPath(); mctx.moveTo(0, i*step); mctx.lineTo(w, i*step); mctx.stroke();
                }
                // 中心クロスヘア
                mctx.strokeStyle = '#fff'; mctx.lineWidth = 2;
                const cxLine = Math.floor(w/2) + 0.5;
                const cyLine = Math.floor(h/2) + 0.5;
                mctx.beginPath(); mctx.moveTo(cxLine, 0); mctx.lineTo(cxLine, h); mctx.stroke();
                mctx.beginPath(); mctx.moveTo(0, cyLine); mctx.lineTo(w, cyLine); mctx.stroke();

                // 位置（キャンバスの右下寄せ）
                const rect = stage.getBoundingClientRect();
                const left = Math.min(rect.width - w - 10, Math.max(10, cx + 20));
                const top  = Math.min(rect.height - h - 10, Math.max(10, cy + 20));
                magnifierCanvas.style.left = left + 'px';
                magnifierCanvas.style.top  = top + 'px';
                magnifierCanvas.style.display = 'block';
            }

            function hideMagnifier() { magnifierCanvas.style.display = 'none'; }

            function setTool(newTool) {
                tool = (tool === newTool) ? null : newTool; // 押し込みトグル
                // UI状態
                canvasPickerBtn.classList.toggle('active', tool === 'picker');
                blurBtn.classList.toggle('active', tool === 'blur');
                const picking = tool === 'picker';
                stage.classList.toggle('picking', picking);
                stageOverlay.style.display = tool ? 'block' : 'none';
                if (!picking) hideMagnifier();
                if (tool !== 'blur') brushCursor.style.display = 'none';
                setStatus(tool === 'picker' ? 'キャンバススポイト: タップ/クリックで確定' :
                          tool === 'blur' ? 'ボカシブラシ: ドラッグで適用' : '');
            }

            // ブラシUI
            function updateBrushUI() {
                brushRadiusVal.textContent = brushRadiusInput.value + 'px';
                brushStrengthVal.textContent = brushStrengthInput.value + 'px';
            }
            brushRadiusInput.addEventListener('input', updateBrushUI);
            brushStrengthInput.addEventListener('input', updateBrushUI);
            updateBrushUI();

            canvasPickerBtn.addEventListener('click', () => {
                setTool('picker');
            });
            blurBtn.addEventListener('click', () => {
                if (!getActiveImage()) { setStatus('先に画像を読み込んでください'); return; }
                setTool('blur');
            });

            // 画面スポイト
            eyedropBtn.addEventListener('click', async () => {
                if (!('EyeDropper' in window)) return;
                try {
                    const ed = new window.EyeDropper();
                    const res = await ed.open();
                    const col = hexToRgba(res.sRGBHex);
                    setCurrentColor(col, true);
                    setStatus('画面スポイトで色を取得しました');
                } catch {
                    setStatus('画面スポイトをキャンセルしました');
                }
            });

            // ポインター共通（スポイト＆ボカシ）
            displayCanvas.addEventListener('pointerdown', (e) => {
                if (!tool) return;
                activePointerId = e.pointerId;
                displayCanvas.setPointerCapture(activePointerId);
                const p = correctedClientPoint(e.clientX, e.clientY);
                handlePointerAt(p.x, p.y, 'down');
            });
            displayCanvas.addEventListener('pointermove', (e) => {
                if (!tool) return;
                if (activePointerId !== e.pointerId) return;
                const p = correctedClientPoint(e.clientX, e.clientY);
                handlePointerAt(p.x, p.y, 'move');
            });
            displayCanvas.addEventListener('pointerup', (e) => {
                if (!tool) return;
                if (activePointerId !== e.pointerId) return;
                const p = correctedClientPoint(e.clientX, e.clientY);
                handlePointerAt(p.x, p.y, 'up');
                displayCanvas.releasePointerCapture(activePointerId);
                activePointerId = null;
            });
            displayCanvas.addEventListener('pointercancel', () => {
                activePointerId = null;
                isDrawing = false;
                brushCursor.style.display = 'none';
                hideMagnifier();
                hideMarker();
            });

            function correctedClientPoint(clientX, clientY) {
                const off = Number.parseInt(touchOffsetValue.value || '0', 10);
                const enable = touchOffsetEnabled.checked;
                return { x: clientX, y: clientY - (enable ? off : 0) };
            }

            function showMarker(rawClientX, rawClientY, corrClientX, corrClientY) {
                const rect = stage.getBoundingClientRect();
                const rawX = rawClientX - rect.left;
                const rawY = rawClientY - rect.top;
                const cx = corrClientX - rect.left;
                const cy = corrClientY - rect.top;

                // マーカー
                touchMarker.style.left = cx + 'px';
                touchMarker.style.top = cy + 'px';
                touchMarker.style.display = 'block';

                // オフセット線（上方向）
                const lineTop = Math.min(cy, rawY);
                const lineBottom = Math.max(cy, rawY);
                offsetLine.style.left = (cx - 1) + 'px';
                offsetLine.style.top = lineTop + 'px';
                offsetLine.style.height = (lineBottom - lineTop) + 'px';
                offsetLine.style.display = (Math.abs(rawY - cy) > 2) ? 'block' : 'none';
            }
            function hideMarker() {
                touchMarker.style.display = 'none';
                offsetLine.style.display = 'none';
            }

            function updateBrushCursor(corrClientX, corrClientY) {
                const act = getActiveImage();
                if (!act) return;
                const dispR = Number(brushRadiusInput.value) * (act.drawnRect.scale || 1);
                const rect = stage.getBoundingClientRect();
                const cx = corrClientX - rect.left;
                const cy = corrClientY - rect.top;
                brushCursor.style.width = (dispR * 2) + 'px';
                brushCursor.style.height = (dispR * 2) + 'px';
                brushCursor.style.left = cx + 'px';
                brushCursor.style.top = cy + 'px';
                brushCursor.style.display = (tool === 'blur') ? 'block' : 'none';
            }

            function handlePointerAt(cX, cY, phase) {
                const act = getActiveImage();
                const rect = stage.getBoundingClientRect();
                // 表示用マーカー（rawは補正前＝下に隠れる指位置としてrect.top+offset付き）
                const off = Number.parseInt(touchOffsetValue.value || '0', 10);
                const rawY = cY + (touchOffsetEnabled.checked ? off : 0);
                showMarker(cX, rawY, cX, cY);

                const map = mapToImagePixel(cX, cY);
                if (!map) {
                    if (phase !== 'move') setStatus('画像範囲外です');
                    brushCursor.style.display = 'none';
                    if (tool === 'picker') hideMagnifier();
                    return;
                }

                if (tool === 'picker') {
                    drawMagnifier(map.px, map.py, map.cx, map.cy);
                    if (phase === 'up') {
                        const pix = readPixel(map.px, map.py);
                        if (pix) {
                            setCurrentColor(pix, true);
                            setStatus('色を取得しました');
                        }
                        // 少し待ってマーカーや拡大鏡を消す
                        setTimeout(() => { hideMagnifier(); hideMarker(); }, 500);
                    }
                } else if (tool === 'blur') {
                    updateBrushCursor(cX, cY);
                    if (phase === 'down') {
                        isDrawing = true;
                        applyBlurAt(map.px, map.py);
                    } else if (phase === 'move') {
                        if (isDrawing) applyBlurAt(map.px, map.py);
                    } else if (phase === 'up') {
                        if (isDrawing) {
                            applyBlurAt(map.px, map.py);
                            isDrawing = false;
                        }
                        setTimeout(() => { hideMarker(); }, 300);
                    }
                }
            }

            function applyBlurAt(px, py) {
                const act = getActiveImage();
                if (!act) return;
                const r = Math.max(1, Number.parseInt(brushRadiusInput.value || '24', 10));
                const blurPx = Math.max(1, Number.parseInt(brushStrengthInput.value || '6', 10));

                const size = r * 2;
                // 元から切り出し
                tmpCanvas.width = size;
                tmpCanvas.height = size;
                tmpCtx.clearRect(0,0,size,size);
                tmpCtx.drawImage(act.sourceCanvas, px - r, py - r, size, size, 0, 0, size, size);

                // ぼかし
                tmpBlurCanvas.width = size;
                tmpBlurCanvas.height = size;
                tmpBlurCtx.clearRect(0,0,size,size);
                tmpBlurCtx.filter = `blur(${blurPx}px)`;
                tmpBlurCtx.drawImage(tmpCanvas, 0, 0);

                // 円でクリップして貼り戻し
                act.sctx.save();
                act.sctx.beginPath();
                act.sctx.arc(px, py, r, 0, Math.PI*2);
                act.sctx.clip();
                act.sctx.drawImage(tmpBlurCanvas, px - r, py - r);
                act.sctx.restore();

                scheduleRedraw();
            }

            function resetColorOutputs() {
                currentSwatch.style.background = '#000';
                currentColorText.textContent = '未取得';
                outHex.textContent = '-';
                outHexa.textContent = '-';
                outRgb.textContent = '-';
                outHsl.textContent = '-';
                outLum.textContent = '-';
                outContB.textContent = '-';
                outContW.textContent = '-';
                sampleOnBlack.style.color = '#fff';
                sampleOnWhite.style.color = '#000';
            }

            // 出力更新（画像ごとに履歴管理）
            function setCurrentColor(col, pushHistory = false) {
                if (!col) return;
                const { r, g, b, a } = col;
                const hex = rgbToHex(r,g,b);
                const hexa = rgbaToHex(r,g,b,a);
                const rgb = toRgbString(r,g,b,a);
                const hsl = toHslString(r,g,b,a);
                const lum = relativeLuminance(r,g,b);
                const contB = contrastRatio(lum, 0);
                const contW = contrastRatio(1, lum);

                currentSwatch.style.background = hexa;
                currentColorText.textContent = `${hex} / ${rgb}`;
                outHex.textContent = hex;
                outHexa.textContent = hexa;
                outRgb.textContent = rgb;
                outHsl.textContent = hsl;
                outLum.textContent = lum.toFixed(4);
                outContB.textContent = contB.toFixed(2);
                outContW.textContent = contW.toFixed(2);
                sampleOnBlack.style.color = hexa;
                sampleOnWhite.style.color = hexa;

                const act = getActiveImage();
                if (act) {
                    act.currentColor = { r, g, b, a };
                    if (pushHistory) {
                        act.history.unshift({ r, g, b, a });
                        if (act.history.length > 60) act.history.pop();
                        renderHistory();
                    }
                }
            }

            function renderHistory() {
                historyContainer.innerHTML = '';
                const act = getActiveImage();
                if (!act || !act.history.length) return;
                act.history.forEach((c) => {
                    const d = document.createElement('button');
                    d.className = 'history-item';
                    d.style.background = rgbaToHex(c.r, c.g, c.b, c.a);
                    d.title = rgbToHex(c.r, c.g, c.b);
                    d.addEventListener('click', () => setCurrentColor(c, false));
                    historyContainer.appendChild(d);
                });
            }

            // 画像入力（複数同時）
            fileInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files || []);
                if (!files.length) return;
                const room = MAX_IMAGES - images.length;
                files.slice(0, room).forEach(loadImageFromFile);
                if (files.length > room) setStatus(`最大${MAX_IMAGES}枚までです。超過分は読み込みませんでした。`);
                fileInput.value = '';
            });
            urlBtn.addEventListener('click', () => {
                const url = urlInput.value.trim();
                if (!url) { setStatus('画像URLを入力してください'); return; }
                if (images.length >= MAX_IMAGES) { setStatus(`最大${MAX_IMAGES}枚までです`); return; }
                loadImageFromSrc(url, true);
            });

            // D&D 複数対応
            stage.addEventListener('dragover', (e) => { e.preventDefault(); stageOverlay.style.display = 'block'; });
            stage.addEventListener('dragleave', () => { stageOverlay.style.display = tool ? 'block' : 'none'; });
            stage.addEventListener('drop', (e) => {
                e.preventDefault();
                stageOverlay.style.display = tool ? 'block' : 'none';
                const files = Array.from(e.dataTransfer.files || []).filter(f => f.type && f.type.startsWith('image/'));
                if (!files.length) return;
                const room = MAX_IMAGES - images.length;
                files.slice(0, room).forEach(loadImageFromFile);
                if (files.length > room) setStatus(`最大${MAX_IMAGES}枚までです。超過分は読み込みませんでした。`);
            });

            // リサイズ追従
            const ro = new ResizeObserver(() => resizeImageStage());
            ro.observe(stage);

            // コピー
            document.querySelectorAll('.copy-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const id = btn.getAttribute('data-copy-target');
                    const el = document.getElementById(id);
                    if (!el) return;
                    try {
                        await navigator.clipboard.writeText(el.textContent.trim());
                        setStatus('クリップボードにコピーしました');
                    } catch {
                        setStatus('コピーに失敗しました');
                    }
                });
            });

            // 初期文言
            setStatus('画像を読み込むとスポイト/ボカシが使えます（タッチ補正ON）');

            // ===========
            // 色変換系
            // ===========
            function clamp01(x){ return Math.min(1, Math.max(0, x)); }
            function pad2(n){ return n.toString(16).padStart(2, '0').toUpperCase(); }

            function rgbToHex(r,g,b){ return '#' + pad2(r) + pad2(g) + pad2(b); }
            function rgbaToHex(r,g,b,a=1){
                const aa = Math.round(clamp01(a) * 255);
                return '#' + pad2(r) + pad2(g) + pad2(b) + pad2(aa);
            }
            function hexToRgba(hex){
                let h = hex.replace('#','').trim();
                if (h.length === 3) {
                    const r = parseInt(h[0]+h[0],16), g = parseInt(h[1]+h[1],16), b = parseInt(h[2]+h[2],16);
                    return { r, g, b, a: 1 };
                } else if (h.length === 6) {
                    const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16);
                    return { r, g, b, a: 1 };
                } else if (h.length === 8) {
                    const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16), a = parseInt(h.slice(6,8),16)/255;
                    return { r, g, b, a };
                }
                return { r:0,g:0,b:0,a:1 };
            }
            function toRgbString(r,g,b,a=1){
                const aa = clamp01(a);
                if (aa < 1) return `rgb(${r} ${g} ${b} / ${+(aa*100).toFixed(1)}%)`;
                return `rgb(${r} ${g} ${b})`;
            }
            function toHslString(r,g,b,a=1){
                const R = r/255, G = g/255, B = b/255;
                const max = Math.max(R,G,B), min = Math.min(R,G,B);
                let h, s, l = (max+min)/2;
                if (max === min) { h = 0; s = 0; }
                else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case R: h = (G - B) / d + (G < B ? 6 : 0); break;
                        case G: h = (B - R) / d + 2; break;
                        case B: h = (R - G) / d + 4; break;
                    }
                    h /= 6;
                }
                const hh = Math.round((h*360) % 360);
                const ss = Math.round(s*100);
                const ll = Math.round(l*100);
                const aa = clamp01(a);
                if (aa < 1) return `hsl(${hh} ${ss}% ${ll}% / ${+(aa*100).toFixed(1)}%)`;
                return `hsl(${hh} ${ss}% ${ll}%)`;
            }
            function srgbToLinearUnit(x){
                // 引数は0..255想定 -> 0..1へ
                const c = x/255;
                return c <= 0.04045 ? c/12.92 : Math.pow((c+0.055)/1.055, 2.4);
            }
            function relativeLuminance(r,g,b){
                const R = srgbToLinearUnit(r), G = srgbToLinearUnit(g), B = srgbToLinearUnit(b);
                return 0.2126*R + 0.7152*G + 0.0722*B;
            }
            function contrastRatio(l1, l2){
                const L1 = Math.max(l1,l2), L2 = Math.min(l1,l2);
                return (L1 + 0.05) / (L2 + 0.05);
            }
        });
    </script>
</body>
</html>
