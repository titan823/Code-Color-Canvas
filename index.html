<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Color Canvas - ライブWebエディタ</title>

    <!-- CodeMirror（CDN） -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/material-darker.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>

    <style>
        /* 全体 */
        :root {
            --bg: #1e1e1e;
            --panel: #252526;
            --panel-2: #2d2d2d;
            --panel-3: #333;
            --border-1: #444;
            --accent: #007acc;
            --text: #d4d4d4;
            --muted: #aaaaaa;
            --ok: #7bd88f;
            --ng: #f26d6d;
            --shadow: rgba(0,0,0,0.35);
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            background-color: var(--panel-3);
            padding: 10px 20px;
            font-size: 1.2em;
            font-weight: bold;
            border-bottom: 2px solid var(--accent);
        }

        /* 上位タブ */
        .main-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }
        .top-tabs {
            display: flex;
            background-color: var(--bg);
            border-bottom: 2px solid var(--border-1);
        }
        .top-tab-button {
            padding: 10px 16px;
            border: none;
            background-color: var(--panel-2);
            color: #ccc;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .top-tab-button + .top-tab-button {
            border-left: 1px solid var(--border-1);
        }
        .top-tab-button.active {
            background-color: var(--panel-3);
            color: white;
            border-bottom: 3px solid var(--accent);
        }

        .page-container {
            position: relative;
            flex: 1;
            min-height: 0;
        }
        .tab-page {
            position: absolute;
            inset: 0;
            display: none;
        }
        .tab-page.active {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        /* パネル共通 */
        .panel-header {
            background-color: var(--panel-3);
            padding: 8px 12px;
            font-weight: bold;
            border-bottom: 1px solid var(--border-1);
            display: flex;
            align-items: center;
            gap: 16px;
        }
        .panel {
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
        }

        /* コードエディタ */
        .code-tabs {
            display: flex;
            background-color: var(--bg);
            border-bottom: 1px solid var(--border-1);
        }
        .tab-button {
            padding: 10px 15px;
            border: none;
            background-color: var(--panel-2);
            color: #ccc;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .tab-button.active {
            background-color: var(--panel-3);
            color: white;
            border-bottom: 3px solid var(--accent);
        }
        .editor-container {
            flex: 1;
            position: relative;
            min-height: 0;
        }
        .CodeMirror {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100% !important;
            font-size: 14px;
        }
        .editor-wrapper {
            display: none;
            height: 100%;
        }
        .editor-wrapper.active {
            display: block;
        }

        /* プレビュー・変更（左右分割） */
        .split-container {
            display: flex;
            flex: 1;
            min-height: 0;
        }
        .split-left, .split-right {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .split-left {
            flex: 1 1 55%;
            border-right: 2px solid var(--border-1);
            min-width: 320px;
        }
        .split-right {
            flex: 1 1 45%;
            min-width: 320px;
        }
        .frame-wrap {
            flex: 1;
            min-height: 0;
        }
        #preview-frame {
            width: 100%;
            height: 100%;
            border: none;
            background-color: #fff;
        }

        /* インスペクター（プレビュー・変更タブ右側） */
        .inspector-body {
            flex: 1;
            background-color: var(--panel);
            padding: 15px;
            overflow-y: auto;
        }
        .inspector-item {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .inspector-item label {
            min-width: 120px;
            font-size: 0.9em;
            color: var(--muted);
        }
        .inspector-item input[type="text"],
        .inspector-item textarea {
            background-color: #3c3c3c;
            border: 1px solid #555;
            color: #f0f0f0;
            padding: 6px 8px;
            border-radius: 3px;
            flex: 1 1 240px;
        }
        .inspector-item textarea {
            min-height: 60px;
            resize: vertical;
        }
        .color-swatch {
            width: 18px;
            height: 18px;
            border: 1px solid #555;
            border-radius: 3px;
            background: transparent;
        }
        .validity-badge {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
            border: 1px solid #555;
            color: #ddd;
        }
        .validity-badge.ok { border-color: #2e7d32; color: var(--ok); }
        .validity-badge.ng { border-color: #8e2a2a; color: var(--ng); }
        .inspector-actions { display: inline-flex; gap: 6px; align-items: center; }
        .btn {
            background: var(--panel-2);
            border: 1px solid #555;
            color: #eee;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        .btn:hover { background: #3a3a3a; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn.active { background: var(--accent); color: white; border-color: var(--accent); }


        /* モード切替 */
        .mode-switcher {
            display: inline-flex;
            margin-left: auto; /* 右寄せ */
            background-color: var(--panel-2);
            border-radius: 4px;
            padding: 2px;
        }
        .mode-switcher .btn {
            padding: 4px 10px;
            font-size: 0.8em;
            border: none;
            background: transparent;
        }
        .mode-switcher .btn.active {
            background-color: var(--accent);
            color: white;
            box-shadow: 0 1px 4px rgba(0,0,0,0.2);
        }

        /* 彩色モード用UI */
        #coloring-ui {
            padding: 10px;
            color: var(--muted);
        }
        #coloring-ui p { margin-top: 0; }
        .color-target-group { display: flex; flex-direction: column; gap: 8px; margin-top: 12px; }
        .color-target-group label { display: flex; align-items: center; gap: 8px; cursor: pointer; }


        /* 画像カラー分析タブ */
        .img-toolbar {
            display: flex; flex-direction: column; gap: 0;
            padding: 8px 12px; background: var(--panel-2); border-bottom: 1px solid var(--border-1);
        }
        .img-toolbar .toolbar-row { width: 100%; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .img-toolbar .toolbar-row + .toolbar-row { margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border-1); }
        .img-toolbar input[type="text"] {
            background: #3c3c3c; border: 1px solid #555; color: #f0f0f0; padding: 6px 8px; border-radius: 3px;
            min-width: 200px; flex: 1 1 200px;
        }
        .img-toolbar input[type="file"] { color: #ddd; }
        .img-switcher {
            display: flex; gap: 6px; align-items: center; flex-wrap: wrap;
            padding: 8px 12px; background: var(--panel-2); border-bottom: 1px solid var(--border-1);
        }
        .img-chip {
            padding: 4px 10px; border: 1px solid #555; border-radius: 16px; background: #2f2f2f; color: #ddd; cursor: pointer;
        }
        .img-chip.active {
            background: var(--accent); border-color: var(--accent); color: #fff;
        }
        .img-stage {
            position: relative; flex: 1; min-height: 0;
            background: conic-gradient(#eee 25%, #fff 0 50%, #eee 0 75%, #fff 0) 0 0 / 16px 16px;
        }
        #image-canvas {
            width: 100%; height: 100%; display: block; background: transparent;
        }
        #magnifier-canvas {
            position: absolute; width: 140px; height: 140px;
            border: 1px solid #666; border-radius: 6px; box-shadow: 0 6px 18px var(--shadow);
            display: none; pointer-events: none; background: #111;
        }
        #blur-magnifier-canvas {
            position: absolute; width: 200px; height: 200px;
            border: 2px solid #ff6600; border-radius: 6px; box-shadow: 0 6px 18px var(--shadow);
            display: none; pointer-events: none; background: #111;
        }
        .img-stage.picking #image-canvas { cursor: crosshair; }
        .img-stage.blurring #image-canvas { cursor: none; } /* カスタムカーソル用 */
        .stage-hint {
            position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
            color: #ccc; font-size: 0.95em; text-align: center; padding: 8px; pointer-events: none;
        }
        .stage-overlay {
            position: absolute; inset: 0; border: 2px dashed #666; border-radius: 8px; pointer-events: none; margin: 8px;
        }
        .panel-section-title { font-weight: bold; margin: 12px 0 6px; color: #fff; }
        .current-color { display: flex; align-items: center; gap: 10px; }
        .swatch-large { width: 64px; height: 64px; border: 1px solid #555; border-radius: 6px; background: #000; }
        .kv-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; flex-wrap: wrap; }
        .kv-row code {
            background: #2a2a2a; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; color: #eee; word-break: break-all;
        }
        .copy-btn { padding: 4px 8px; }
        .contrast-box { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 6px; }
        .contrast-sample { height: 48px; display: flex; align-items: center; justify-content: center; border-radius: 6px; border: 1px solid #555; font-weight: 600; }
        .history-list { display: flex; flex-wrap: wrap; gap: 8px; }
        .history-item { width: 28px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer; }
        .status-line { font-size: 0.85em; color: #ccc; padding: 4px 12px; border-top: 1px solid #444; background: #2b2b2b; }
        .note { color: #bbb; font-size: 0.85em; }

        .touch-offset-group {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        .touch-offset-group input[type="number"] { padding: 2px 4px; width: 60px; }

        .brush-settings {
            padding: 8px 12px;
            background: var(--panel-2);
            border-bottom: 1px solid var(--border-1);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        .brush-settings label { display: flex; align-items: center; gap: 6px; }
        .brush-settings input[type="range"] { width: 120px; }
        .brush-settings .separator {
            width: 1px;
            height: 20px;
            background: var(--border-1);
            margin: 0 8px;
        }

        .adjust-settings {
            padding: 8px 12px;
            background: var(--panel-2);
            border-bottom: 1px solid var(--border-1);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        .adjust-settings label { display: flex; align-items: center; gap: 6px; }
        .adjust-settings input[type="range"] { width: 160px; }

        #pointer-marker {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 2px solid #00ff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        #pointer-marker::before,
        #pointer-marker::after {
            content: '';
            position: absolute;
            background: #00ff00;
        }
        #pointer-marker::before {
            width: 2px;
            height: 8px;
            left: 50%;
            top: -10px;
            transform: translateX(-50%);
        }
        #pointer-marker::after {
            width: 8px;
            height: 2px;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
        }

        #brush-preview {
            position: absolute;
            border: 2px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            display: none;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.5);
            transform: translate(-50%, -50%);
        }

        #offset-line {
            position: absolute;
            border-left: 1px dashed rgba(255,255,255,0.5);
            pointer-events: none;
            z-index: 998;
            display: none;
            transform-origin: top left;
        }

        /* ★★★ カラー編集タブのスタイル ★★★ */
        .colorlab-container {
            display: flex;
            flex: 1;
            min-height: 0;
        }
        .colorlab-left, .colorlab-right {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .colorlab-left {
            flex: 1 1 50%;
            border-right: 2px solid var(--border-1);
        }
        .colorlab-right {
            flex: 1 1 50%;
        }
        .colorlab-body {
            flex: 1;
            background-color: var(--panel);
            padding: 20px;
            overflow-y: auto;
        }
        #colorlab-swatch {
            width: 100%;
            height: 96px;
            border: 1px solid var(--border-1);
            border-radius: 6px;
            margin-top: 8px;
            background-image: conic-gradient(#ccc 25%, #fff 0 50%, #ccc 0 75%, #fff 0) 0 0 / 16px 16px;
        }
        .colorlab-slider-group {
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .colorlab-slider-group label { color: var(--muted); }
        .colorlab-slider-group input[type="range"] { width: 100%; }
        .colorlab-slider-group span { min-width: 40px; text-align: right; }
        .colorlab-lock-group {
            display: flex; gap: 12px; margin: 12px 0;
        }
        .colorlab-actions {
            display: flex; flex-wrap: wrap; gap: 8px; margin-top: 16px;
        }

    </style>
</head>
<body>
    <header>Code Color Canvas</header>

    <main class="main-container">
        <!-- 上位タブ -->
        <div class="top-tabs">
            <button class="top-tab-button active" onclick="showMainTab('code')">コード編集</button>
            <button class="top-tab-button" onclick="showMainTab('preview')">プレビュー・変更</button>
            <button class="top-tab-button" onclick="showMainTab('image')">画像カラー分析</button>
            <!-- ★★★ 新しいタブボタンを追加 ★★★ -->
            <button class="top-tab-button" onclick="showMainTab('colorlab')">カラー編集</button>
        </div>

        <div class="page-container">
            <!-- コード編集タブ -->
            <section id="code-page" class="tab-page active">
                <div class="panel code-panel">
                    <div class="panel-header">コード編集</div>
                    <div class="code-tabs">
                        <button class="tab-button active" onclick="showEditor('html')">HTML</button>
                        <button class="tab-button" onclick="showEditor('css')">CSS</button>
                        <button class="tab-button" onclick="showEditor('js')">JavaScript</button>
                    </div>
                    <div class="editor-container">
                        <div id="html-editor-wrapper" class="editor-wrapper active">
                            <textarea id="html-code"></textarea>
                        </div>
                        <div id="css-editor-wrapper" class="editor-wrapper">
                            <textarea id="css-code"></textarea>
                        </div>
                        <div id="js-editor-wrapper" class="editor-wrapper">
                            <textarea id="js-code"></textarea>
                        </div>
                    </div>
                </div>
            </section>

            <!-- プレビュー・変更タブ -->
            <section id="preview-page" class="tab-page">
                <div class="split-container">
                    <div class="split-left">
                        <div class="panel-header">プレビュー</div>
                        <div class="frame-wrap">
                            <iframe id="preview-frame"></iframe>
                        </div>
                    </div>
                    <div class="split-right">
                        <div class="panel-header">
                            <span>インスペクター</span>
                            <div class="mode-switcher">
                                <button id="mode-action" class="btn active" onclick="switchMode('action')">操作モード</button>
                                <button id="mode-color" class="btn" onclick="switchMode('color')">彩色モード</button>
                            </div>
                        </div>
                        <div class="inspector-body">
                            <p id="inspector-placeholder">プレビュー内の要素をクリックすると、ここでテキストやスタイルを編集できます。</p>
                            
                            <div id="coloring-ui" style="display: none;">
                                <p>「画像カラー分析」または「カラー編集」タブで取得・作成した色を適用します。</p>
                                <p>先に色を準備してから、プレビュー内の要素をクリックしてください。</p>
                                <div class="color-target-group">
                                    <label>
                                        <input type="radio" name="color-target" value="color" checked>
                                        テキスト色に適用
                                    </label>
                                    <label>
                                        <input type="radio" name="color-target" value="backgroundColor">
                                        背景色に適用
                                    </label>
                                </div>
                            </div>
                            
                            <div id="inspector-ui" style="display: none;">
                                <div class="inspector-item">
                                    <label>選択中の要素</label>
                                    <b id="selected-element-selector"></b>
                                </div>
                                <div class="inspector-item">
                                    <label for="inspector-text">テキスト</label>
                                    <textarea id="inspector-text" placeholder="選択した要素のテキストを編集"></textarea>
                                    <div class="inspector-actions">
                                        <label style="display:inline-flex; align-items:center; gap:6px; color:#ccc; font-size: 0.9em;">
                                            <input type="checkbox" id="inspector-text-as-html"> HTMLとして編集
                                        </label>
                                        <button class="btn" id="apply-text">適用</button>
                                    </div>
                                </div>
                                <div class="inspector-item">
                                    <label for="inspector-color">テキスト色</label>
                                    <input type="text" id="inspector-color" placeholder="例: #ff8800, rgb(255 136 0 / 80%)">
                                    <span class="color-swatch" id="swatch-color"></span>
                                    <span class="validity-badge" id="valid-color">未入力</span>
                                    <div class="inspector-actions">
                                        <button class="btn" id="apply-color" disabled>適用</button>
                                        <button class="btn" id="undo-color" disabled>元に戻す</button>
                                        <button class="btn" id="redo-color" disabled>やり直す</button>
                                    </div>
                                </div>
                                <div class="inspector-item">
                                    <label for="inspector-bg">背景色</label>
                                    <input type="text" id="inspector-bg" placeholder="例: transparent, #222, lch(50 60 40)">
                                    <span class="color-swatch" id="swatch-bg"></span>
                                    <span class="validity-badge" id="valid-bg">未入力</span>
                                    <div class="inspector-actions">
                                        <button class="btn" id="apply-bg" disabled>適用</button>
                                        <button class="btn" id="undo-bg" disabled>元に戻す</button>
                                        <button class="btn" id="redo-bg" disabled>やり直す</button>
                                    </div>
                                </div>
                                <div class="inspector-item">
                                    <label for="inspector-padding">パディング</label>
                                    <input type="text" id="inspector-padding" placeholder="例: 10px / 8px 12px">
                                </div>
                                <div class="inspector-item">
                                    <label for="inspector-margin">マージン</label>
                                    <input type="text" id="inspector-margin" placeholder="例: 10px auto">
                                </div>
                                <div class="inspector-item">
                                    <label for="inspector-fontSize">フォントサイズ</label>
                                    <input type="text" id="inspector-fontSize" placeholder="例: 16px / 1.2rem">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 画像カラー分析タブ -->
            <section id="image-page" class="tab-page">
                <div class="split-container">
                    <div class="split-left">
                        <div class="panel-header">画像</div>
                        <div class="img-toolbar">
                            <div class="toolbar-row">
                                <input type="file" id="img-file" accept="image/*" multiple>
                                <input type="text" id="img-url" placeholder="画像URL（CORS対応のもの）">
                                <button class="btn" id="btn-load-url">読込</button>
                            </div>
                            <div class="toolbar-row">
                                <button class="btn" id="btn-eyedropper" title="対応ブラウザのみ">画面スポイト</button>
                                <button class="btn" id="btn-canvas-picker">キャンバススポイト</button>
                                <button class="btn" id="btn-blur-brush">ボカシブラシ</button>
                                <div class="touch-offset-group">
                                    <label><input type="checkbox" id="touch-offset-enabled" checked>タッチオフセット</label>
                                    <input type="number" id="touch-offset-value" value="100" min="0" max="200">
                                    <span>px</span>
                                </div>
                            </div>
                        </div>
                        <div class="brush-settings" id="blur-brush-settings" style="display: none;">
                            <label>ブラシサイズ: <span id="brush-size-display">20</span>px</label>
                            <input type="range" id="brush-size" min="5" max="100" value="20">
                            <label>ボカシ強度: <span id="blur-strength-display">12</span>px</label>
                            <input type="range" id="blur-strength" min="1" max="200" value="12">
                            <div class="separator"></div>
                            <label>拡大鏡: <span id="blur-zoom-display">2</span>倍</label>
                            <input type="range" id="blur-zoom" min="1" max="8" value="2" step="0.5">
                            <label><input type="checkbox" id="blur-magnifier-enabled" checked>拡大鏡を表示</label>
                            <button class="btn" id="btn-undo-blur" disabled>元に戻す</button>
                            <button class="btn" id="btn-reset-blur" disabled>リセット</button>
                        </div>
                        <div class="adjust-settings" id="adjust-settings">
                            <label>彩度: <span id="sat-display">100</span>%</label>
                            <input type="range" id="sat-range" min="0" max="300" value="100">
                            <label>明るさ(輝度): <span id="bri-display">100</span>%</label>
                            <input type="range" id="bri-range" min="0" max="200" value="100">
                            <button class="btn" id="btn-reset-adjust">色調整リセット</button>
                        </div>
                        <div class="img-switcher" id="img-switcher"></div>
                        <div class="img-stage" id="image-stage">
                            <canvas id="image-canvas"></canvas>
                            <canvas id="magnifier-canvas" width="140" height="140"></canvas>
                            <canvas id="blur-magnifier-canvas" width="200" height="200"></canvas>
                            <div class="stage-hint" id="stage-hint">画像を読み込むか、ここにドラッグ＆ドロップしてください（複数可）</div>
                            <div class="stage-overlay" id="stage-overlay" style="display:none;"></div>
                        </div>
                        <div class="status-line" id="img-status"></div>
                    </div>
                    <div class="split-right">
                        <div class="panel-header">カラー分析</div>
                        <div class="inspector-body" id="image-inspector">
                            <div class="panel-section-title">現在の色</div>
                            <div class="current-color">
                                <div class="swatch-large" id="current-swatch"></div>
                                <div id="current-color-text">未取得</div>
                            </div>
                            <div class="panel-section-title">表記</div>
                            <div class="kv-row"><label style="min-width:80px;">HEX</label><code id="hex-val">-</code><button class="btn copy-btn" data-copy-target="hex-val">コピー</button></div>
                            <div class="kv-row"><label style="min-width:80px;">HEXA</label><code id="hexa-val">-</code><button class="btn copy-btn" data-copy-target="hexa-val">コピー</button></div>
                            <div class="kv-row"><label style="min-width:80px;">RGB(A)</label><code id="rgb-val">-</code><button class="btn copy-btn" data-copy-target="rgb-val">コピー</button></div>
                            <div class="kv-row"><label style="min-width:80px;">HSL(A)</label><code id="hsl-val">-</code><button class="btn copy-btn" data-copy-target="hsl-val">コピー</button></div>
                            <div class="panel-section-title">視認性</div>
                            <div class="kv-row"><label style="min-width:120px;">相対輝度</label><code id="luminance-val">-</code></div>
                            <div class="kv-row"><label style="min-width:120px;">コントラスト比</label>
                                <div>対黒: <code id="contrast-black">-</code></div>
                                <div>対白: <code id="contrast-white">-</code></div>
                            </div>
                            <div class="contrast-box">
                                <div class="contrast-sample" id="contrast-on-black" style="background:#000;color:#fff;">サンプル</div>
                                <div class="contrast-sample" id="contrast-on-white" style="background:#fff;color:#000;">サンプル</div>
                            </div>
                            <div class="panel-section-title">履歴（画像ごとに保存）</div>
                            <div class="history-list" id="history-list"></div>
                            <p class="note">画面スポイトはChrome/Edgeなどで使用可能です。URL読み込みはCORS対応の画像のみキャンバス内スポイトが動作します。</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- ★★★ 新しいカラー編集タブ ★★★ -->
            <section id="colorlab-page" class="tab-page">
                <div class="colorlab-container">
                    <!-- 左：操作パネル -->
                    <div class="colorlab-left">
                        <div class="panel-header">カラー調整</div>
                        <div class="colorlab-body">
                            <div class="inspector-item">
                                <input type="text" id="colorlab-input" placeholder="色コードを入力 (例: #ff8800, blue)">
                                <span class="validity-badge" id="colorlab-valid">未入力</span>
                            </div>
                            <div id="colorlab-swatch"></div>
                            
                            <div class="panel-section-title">調整モード</div>
                            <div class="colorlab-lock-group">
                                <label><input type="checkbox" id="colorlab-lock-lightness" checked> 輝度のみ変更</label>
                            </div>

                            <div class="panel-section-title">HSL調整</div>
                            <div class="colorlab-slider-group">
                                <label for="colorlab-hue">H</label>
                                <input type="range" id="colorlab-hue" min="0" max="360" value="0">
                                <span id="colorlab-hue-val">0</span>
                            </div>
                            <div class="colorlab-slider-group">
                                <label for="colorlab-sat">S</label>
                                <input type="range" id="colorlab-sat" min="0" max="100" value="0">
                                <span id="colorlab-sat-val">0%</span>
                            </div>
                            <div class="colorlab-slider-group">
                                <label for="colorlab-light">L</label>
                                <input type="range" id="colorlab-light" min="0" max="100" value="0">
                                <span id="colorlab-light-val">0%</span>
                            </div>
                            <div class="colorlab-slider-group">
                                <label for="colorlab-alpha">A</label>
                                <input type="range" id="colorlab-alpha" min="0" max="100" value="100">
                                <span id="colorlab-alpha-val">100%</span>
                            </div>

                            <div class="colorlab-actions">
                                <button class="btn" id="colorlab-btn-reset">リセット</button>
                                <button class="btn" id="colorlab-btn-pull">画像を読み込む</button>
                                <button class="btn" id="colorlab-btn-send">彩色モードへ送る</button>
                            </div>
                            <p class="note" style="margin-top: 16px;">「画像を読み込む」ボタンで、画像タブで取得した色を呼び出せます。</p>
                        </div>
                    </div>
                    <!-- 右：分析パネル -->
                    <div class="colorlab-right">
                        <div class="panel-header">分析結果</div>
                        <div class="colorlab-body">
                            <div class="panel-section-title">表記</div>
                            <div class="kv-row"><label style="min-width:80px;">HEX</label><code id="colorlab-hex-val">-</code><button class="btn copy-btn" data-copy-target="colorlab-hex-val">コピー</button></div>
                            <div class="kv-row"><label style="min-width:80px;">HEXA</label><code id="colorlab-hexa-val">-</code><button class="btn copy-btn" data-copy-target="colorlab-hexa-val">コピー</button></div>
                            <div class="kv-row"><label style="min-width:80px;">RGB(A)</label><code id="colorlab-rgb-val">-</code><button class="btn copy-btn" data-copy-target="colorlab-rgb-val">コピー</button></div>
                            <div class="kv-row"><label style="min-width:80px;">HSL(A)</label><code id="colorlab-hsl-val">-</code><button class="btn copy-btn" data-copy-target="colorlab-hsl-val">コピー</button></div>

                            <div class="panel-section-title">視認性</div>
                            <div class="kv-row"><label style="min-width:120px;">相対輝度</label><code id="colorlab-luminance-val">-</code></div>
                            <div class="kv-row"><label style="min-width:120px;">コントラスト比</label>
                                <div>対黒: <code id="colorlab-contrast-black">-</code></div>
                                <div>対白: <code id="colorlab-contrast-white">-</code></div>
                            </div>
                            <div class="contrast-box">
                                <div class="contrast-sample" id="colorlab-on-black" style="background:#000;color:#fff;">サンプル</div>
                                <div class="contrast-sample" id="colorlab-on-white" style="background:#fff;color:#000;">サンプル</div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- グローバル変数群 ---
            let selectedElement = null;
            let lastHighlightedElement = null;
            let lastSelectedSelectorPath = null;
            let currentMode = 'action';
            let globalCurrentColor = null;

            const colorHistory = new Map();
            function getHistory(selector) {
                if (!colorHistory.has(selector)) {
                    colorHistory.set(selector, {
                        color: { undo: [], redo: [] },
                        backgroundColor: { undo: [], redo: [] }
                    });
                }
                return colorHistory.get(selector);
            }

            // --- CodeMirror 初期化 ---
            const htmlEditor = CodeMirror.fromTextArea(document.getElementById('html-code'), {
                mode: 'xml', htmlMode: true, theme: 'material-darker', lineNumbers: true,
            });
            const cssEditor = CodeMirror.fromTextArea(document.getElementById('css-code'), {
                mode: 'css', theme: 'material-darker', lineNumbers: true,
            });
            const jsEditor = CodeMirror.fromTextArea(document.getElementById('js-code'), {
                mode: 'javascript', theme: 'material-darker', lineNumbers: true,
            });

            // --- 初期コード ---
            const initialHTML = `<div class="container">
  <h1 id="main-title">Code Color Canvasへようこそ！</h1>
  <p>ここにあるテキストやスタイルを自由に編集できます。</p>
  <button id="action-btn">クリック</button>
</div>`;
            const initialCSS = `body { font-family: system-ui, sans-serif; background-color: #f0f0f0; display: flex; justify-content: center; align-items: center; height: 100%; margin: 0; }
.container { text-align: center; padding: 40px; background-color: white; border-radius: 12px; box-shadow: 0 6px 16px rgba(0,0,0,0.12); }
#main-title { color: #333; margin: 0 0 10px 0; }
#action-btn { background-color: #007acc; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 16px; }`;
            const initialJS = `document.getElementById('action-btn')?.addEventListener('click', () => alert('ボタンがクリックされました！'));`;

            htmlEditor.setValue(initialHTML);
            cssEditor.setValue(initialCSS);
            jsEditor.setValue(initialJS);

            // --- タブ制御 ---
            window.showMainTab = function(name) {
                document.querySelectorAll('.top-tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-page').forEach(p => p.classList.remove('active'));
                document.querySelector(`.top-tab-button[onclick="showMainTab('${name}')"]`).classList.add('active');
                
                const pageId = `${name}-page`;
                document.getElementById(pageId).classList.add('active');

                if (name === 'code') {
                    htmlEditor.refresh(); cssEditor.refresh(); jsEditor.refresh();
                } else if (name === 'image') {
                    if (typeof resizeImageStage === 'function') resizeImageStage();
                } else if (name === 'preview') {
                    switchMode(currentMode);
                }
            };

            window.showEditor = function(editorName) {
                document.querySelectorAll('.editor-wrapper').forEach(w => w.classList.remove('active'));
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                document.getElementById(`${editorName}-editor-wrapper`).classList.add('active');
                document.querySelector(`.tab-button[onclick="showEditor('${editorName}')"]`).classList.add('active');
                if (editorName === 'html') htmlEditor.refresh();
                if (editorName === 'css') cssEditor.refresh();
                if (editorName === 'js') jsEditor.refresh();
            };

            // --- プレビュー更新 ---
            function updatePreview() {
                const iframe = document.getElementById('preview-frame');
                const doc = iframe.contentDocument || iframe.contentWindow.document;
                doc.open();
                doc.write(`<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><style>${cssEditor.getValue()}</style></head><body>${htmlEditor.getValue()}<script>(function(){${jsEditor.getValue()}})();<\/script></body></html>`);
                doc.close();
                setupInspectorListeners();
                switchMode(currentMode);
                if (!restoreSelection()) {
                    selectedElement = null;
                    lastHighlightedElement = null;
                    showInspectorPlaceholder();
                }
            }
            htmlEditor.on('change', updatePreview);
            cssEditor.on('change', updatePreview);
            jsEditor.on('change', updatePreview);

            // --- モード切替 ---
            window.switchMode = function(mode) {
                currentMode = mode;
                document.getElementById('mode-action').classList.toggle('active', mode === 'action');
                document.getElementById('mode-color').classList.toggle('active', mode === 'color');
                const inspectorUI = document.getElementById('inspector-ui');
                const coloringUI = document.getElementById('coloring-ui');
                const placeholder = document.getElementById('inspector-placeholder');
                const iframe = document.getElementById('preview-frame');
                const pdoc = iframe.contentDocument || iframe.contentWindow.document;
                if (mode === 'action') {
                    coloringUI.style.display = 'none';
                    if (selectedElement) {
                        inspectorUI.style.display = 'block';
                        placeholder.style.display = 'none';
                    } else {
                        inspectorUI.style.display = 'none';
                        placeholder.style.display = 'block';
                    }
                    if (pdoc && pdoc.body) pdoc.body.style.cursor = 'default';
                } else {
                    inspectorUI.style.display = 'none';
                    placeholder.style.display = 'none';
                    coloringUI.style.display = 'block';
                    if (pdoc && pdoc.body) pdoc.body.style.cursor = 'crosshair';
                }
            }

            // --- インスペクター ---
            function setupInspectorListeners() {
                const iframe = document.getElementById('preview-frame');
                const pbody = iframe.contentDocument?.body;
                if (!pbody) return;
                pbody.addEventListener('click', (e) => {
                    e.preventDefault(); e.stopPropagation();
                    if (currentMode === 'action') {
                        if (lastHighlightedElement) lastHighlightedElement.style.outline = '';
                        selectedElement = e.target;
                        selectedElement.style.outline = '2px solid var(--accent)';
                        lastHighlightedElement = selectedElement;
                        lastSelectedSelectorPath = getCssSelector(selectedElement);
                        populateInspector(selectedElement);
                    } else if (currentMode === 'color') {
                        if (!globalCurrentColor) { alert('先に色を準備してください。'); return; }
                        selectedElement = e.target;
                        lastSelectedSelectorPath = getCssSelector(e.target);
                        const prop = document.querySelector('input[name="color-target"]:checked').value;
                        const colorStr = toRgbString(globalCurrentColor.r, globalCurrentColor.g, globalCurrentColor.b, globalCurrentColor.a);
                        applyStyleChange(prop, colorStr);
                        e.target.style.outline = '3px solid var(--ok)';
                        setTimeout(() => { if (e.target.style.outline === '3px solid var(--ok)') e.target.style.outline = ''; }, 500);
                    }
                }, { capture: true });
            }

            function restoreSelection() {
                if (!lastSelectedSelectorPath) return false;
                const el = document.getElementById('preview-frame').contentDocument?.querySelector(lastSelectedSelectorPath);
                if (el) {
                    if (lastHighlightedElement) lastHighlightedElement.style.outline = '';
                    selectedElement = el;
                    if (currentMode === 'action') {
                        selectedElement.style.outline = '2px solid var(--accent)';
                        lastHighlightedElement = selectedElement;
                        populateInspector(selectedElement);
                    }
                    return true;
                }
                return false;
            }

            function getCssSelector(el) {
                if (!el || el.nodeType !== 1) return '';
                const parts = [];
                while (el && el.nodeType === 1) {
                    let selector = el.nodeName.toLowerCase();
                    if (el.id) { parts.unshift('#' + el.id); break; }
                    else {
                        if (el.classList.length) selector += '.' + Array.from(el.classList).join('.');
                        let sib = el, nth = 1;
                        while (sib = sib.previousElementSibling) if (sib.nodeName === el.nodeName) nth++;
                        if (nth !== 1) selector += `:nth-of-type(${nth})`;
                    }
                    parts.unshift(selector);
                    if (el.parentNode?.nodeName === 'BODY') break;
                    el = el.parentNode;
                }
                return parts.join(' > ');
            }

            function showInspectorPlaceholder() {
                document.getElementById('inspector-placeholder').style.display = 'block';
                document.getElementById('inspector-ui').style.display = 'none';
                document.getElementById('coloring-ui').style.display = 'none';
            }

            function populateInspector(element) {
                if (currentMode !== 'action') return;
                document.getElementById('inspector-placeholder').style.display = 'none';
                document.getElementById('coloring-ui').style.display = 'none';
                document.getElementById('inspector-ui').style.display = 'block';
                const styles = window.getComputedStyle(element);
                document.getElementById('selected-element-selector').textContent = getCssSelector(element);
                document.getElementById('inspector-text-as-html').checked = false;
                document.getElementById('inspector-text').value = element.textContent ?? '';
                document.getElementById('inspector-color').value = styles.color || '';
                document.getElementById('inspector-bg').value = styles.backgroundColor || '';
                updateColorUI('color'); updateColorUI('bg'); updateApplyButtons(); updateHistoryButtons();
                document.getElementById('inspector-padding').value = styles.padding || '';
                document.getElementById('inspector-margin').value = styles.margin || '';
                document.getElementById('inspector-fontSize').value = styles.fontSize || '';
            }

            function applyStyleChange(property, value) {
                if (!selectedElement) return;
                selectedElement.style[property] = value;
                const selector = getCssSelector(selectedElement);
                let cssCode = cssEditor.getValue();
                const cssProperty = property.replace(/([A-Z])/g, '-$1').toLowerCase();
                const esc = selector.replace(/[\/\\^$*+?.()|[\]{}]/g, '\\$&');
                const regex = new RegExp(`(${esc})\\s*\\{([^}]*)\\}`, 's');
                const match = cssCode.match(regex);
                if (match) {
                    let props = match[2];
                    const propRegex = new RegExp(`(^|;)\\s*${cssProperty}\\s*:[^;]*`, 'i');
                    if (propRegex.test(props)) cssCode = cssCode.replace(match[0], `${selector} {${props.replace(propRegex, `$1 ${cssProperty}: ${value}`)}}`);
                    else cssCode = cssCode.replace(match[0], `${selector} {\n${props.trim()}${props.trim() && !props.trim().endsWith(';') ? ';' : ''} ${cssProperty}: ${value}; \n}`);
                } else {
                    cssCode += `\n\n${selector} {\n    ${cssProperty}: ${value};\n}`;
                }
                lastSelectedSelectorPath = selector;
                cssEditor.setValue(cssCode);
            }

            function isValidCSSColor(value) { return CSS.supports('color', value); }
            function updateColorUI(kind) {
                const input = document.getElementById(kind === 'color' ? 'inspector-color' : 'inspector-bg');
                const swatch = document.getElementById(kind === 'color' ? 'swatch-color' : 'swatch-bg');
                const badge = document.getElementById(kind === 'color' ? 'valid-color' : 'valid-bg');
                const val = input.value.trim();
                if (!val) { swatch.style.background = 'transparent'; badge.textContent = '未入力'; badge.className = 'validity-badge'; }
                else if (isValidCSSColor(val)) { swatch.style.background = val; badge.textContent = 'OK'; badge.className = 'validity-badge ok'; }
                else { swatch.style.background = 'transparent'; badge.textContent = '不正'; badge.className = 'validity-badge ng'; }
                updateApplyButtons();
            }
            function updateApplyButtons() {
                document.getElementById('apply-color').disabled = !(selectedElement && isValidCSSColor(document.getElementById('inspector-color').value.trim()));
                document.getElementById('apply-bg').disabled = !(selectedElement && isValidCSSColor(document.getElementById('inspector-bg').value.trim()));
            }
            function updateHistoryButtons() {
                const h = lastSelectedSelectorPath ? colorHistory.get(lastSelectedSelectorPath) : null;
                document.getElementById('undo-color').disabled = !(h?.color.undo.length);
                document.getElementById('undo-bg').disabled = !(h?.backgroundColor.undo.length);
                document.getElementById('redo-color').disabled = !(h?.color.redo.length);
                document.getElementById('redo-bg').disabled = !(h?.backgroundColor.redo.length);
            }

            ['inspector-color', 'inspector-bg'].forEach(id => document.getElementById(id).addEventListener('input', () => updateColorUI(id.includes('bg') ? 'bg' : 'color')));
            document.getElementById('apply-color').addEventListener('click', () => commitColor('color'));
            document.getElementById('apply-bg').addEventListener('click', () => commitColor('backgroundColor'));
            document.getElementById('undo-color').addEventListener('click', () => undoColor('color'));
            document.getElementById('undo-bg').addEventListener('click', () => undoColor('backgroundColor'));
            document.getElementById('redo-color').addEventListener('click', () => redoColor('color'));
            document.getElementById('redo-bg').addEventListener('click', () => redoColor('backgroundColor'));

            function commitColor(prop) {
                if (!selectedElement) return;
                const input = document.getElementById(prop === 'color' ? 'inspector-color' : 'inspector-bg');
                const val = input.value.trim();
                if (!isValidCSSColor(val)) return;
                const selector = getCssSelector(selectedElement);
                lastSelectedSelectorPath = selector;
                const prev = window.getComputedStyle(selectedElement)[prop];
                const h = getHistory(selector);
                h[prop].undo.push(prev);
                h[prop].redo.length = 0;
                updateHistoryButtons();
                applyStyleChange(prop, val);
            }
            function undoRedo(action, prop) {
                const selector = lastSelectedSelectorPath;
                if (!selector) return;
                const h = colorHistory.get(selector);
                const from = action === 'undo' ? h[prop].undo : h[prop].redo;
                const to = action === 'undo' ? h[prop].redo : h[prop].undo;
                if (!from.length) return;
                const currentVal = window.getComputedStyle(selectedElement)[prop];
                to.push(currentVal);
                const val = from.pop();
                document.getElementById(prop === 'color' ? 'inspector-color' : 'inspector-bg').value = val || '';
                updateColorUI(prop === 'color' ? 'color' : 'bg');
                applyStyleChange(prop, val);
                updateHistoryButtons();
            }
            function undoColor(prop) { undoRedo('undo', prop); }
            function redoColor(prop) { undoRedo('redo', prop); }

            document.getElementById('inspector-text-as-html').addEventListener('change', (e) => {
                if (!selectedElement) return;
                document.getElementById('inspector-text').value = e.target.checked ? (selectedElement.innerHTML ?? '') : (selectedElement.textContent ?? '');
            });
            document.getElementById('apply-text').addEventListener('click', () => {
                if (!selectedElement) return;
                const selector = getCssSelector(selectedElement);
                lastSelectedSelectorPath = selector;
                const value = document.getElementById('inspector-text').value ?? '';
                const asHTML = document.getElementById('inspector-text-as-html').checked;
                if (asHTML) selectedElement.innerHTML = value; else selectedElement.textContent = value;
                const wrapper = document.createElement('div');
                wrapper.innerHTML = htmlEditor.getValue();
                const target = wrapper.querySelector(selector);
                if (target) {
                    if (asHTML) target.innerHTML = value; else target.textContent = value;
                    htmlEditor.setValue(wrapper.innerHTML.trim());
                }
            });

            ['padding', 'margin', 'fontSize'].forEach(prop => {
                document.getElementById(`inspector-${prop}`).addEventListener('change', (e) => {
                    const value = e.target.value.trim();
                    if (value && selectedElement) {
                        lastSelectedSelectorPath = getCssSelector(selectedElement);
                        applyStyleChange(prop, value);
                    }
                });
            });

            // --- 初期描画 ---
            updatePreview();
            showMainTab('code');

            // --- 画像カラー分析タブ ---
            // (このセクションのコードは変更なし)
            const MAX_IMAGES = 10;
            let images = [];
            let activeIndex = -1;
            const stage = document.getElementById('image-stage');
            const displayCanvas = document.getElementById('image-canvas');
            const dctx = displayCanvas.getContext('2d');
            const magnifierCanvas = document.getElementById('magnifier-canvas');
            const mctx = magnifierCanvas.getContext('2d');
            mctx.imageSmoothingEnabled = false;
            const blurMagnifierCanvas = document.getElementById('blur-magnifier-canvas');
            const bmctx = blurMagnifierCanvas.getContext('2d');
            bmctx.imageSmoothingEnabled = false;
            const statusLine = document.getElementById('img-status');
            const stageHint = document.getElementById('stage-hint');
            const stageOverlay = document.getElementById('stage-overlay');
            const switcher = document.getElementById('img-switcher');
            const fileInput = document.getElementById('img-file');
            const urlInput = document.getElementById('img-url');
            const urlBtn = document.getElementById('btn-load-url');
            const eyedropBtn = document.getElementById('btn-eyedropper');
            const canvasPickerBtn = document.getElementById('btn-canvas-picker');
            const blurBrushBtn = document.getElementById('btn-blur-brush');
            const blurSettingsPanel = document.getElementById('blur-brush-settings');
            const brushSizeInput = document.getElementById('brush-size');
            const brushSizeDisplay = document.getElementById('brush-size-display');
            const blurStrengthInput = document.getElementById('blur-strength');
            const blurStrengthDisplay = document.getElementById('blur-strength-display');
            const blurZoomInput = document.getElementById('blur-zoom');
            const blurZoomDisplay = document.getElementById('blur-zoom-display');
            const blurMagnifierEnabled = document.getElementById('blur-magnifier-enabled');
            const undoBlurBtn = document.getElementById('btn-undo-blur');
            const resetBlurBtn = document.getElementById('btn-reset-blur');
            const adjustSettingsPanel = document.getElementById('adjust-settings');
            const satRange = document.getElementById('sat-range');
            const briRange = document.getElementById('bri-range');
            const satDisplay = document.getElementById('sat-display');
            const briDisplay = document.getElementById('bri-display');
            const resetAdjustBtn = document.getElementById('btn-reset-adjust');
            let isColorAdjusting = false;
            let adjustBase = null;
            let toolMode = 'none';
            let isDrawing = false;
            let brushSize = 20;
            let blurStrength = 12;
            let blurZoomLevel = 2;
            const touchOffsetEnabledCheck = document.getElementById('touch-offset-enabled');
            const touchOffsetValueInput = document.getElementById('touch-offset-value');
            let touchOffsetEnabled = true;
            let touchOffsetValue = 100;
            const pointerMarker = document.createElement('div');
            pointerMarker.id = 'pointer-marker';
            stage.appendChild(pointerMarker);
            const brushPreview = document.createElement('div');
            brushPreview.id = 'brush-preview';
            stage.appendChild(brushPreview);
            const offsetLine = document.createElement('div');
            offsetLine.id = 'offset-line';
            stage.appendChild(offsetLine);
            const historyContainer = document.getElementById('history-list');
            const currentSwatch = document.getElementById('current-swatch');
            const currentColorText = document.getElementById('current-color-text');
            const outHex = document.getElementById('hex-val');
            const outHexa = document.getElementById('hexa-val');
            const outRgb = document.getElementById('rgb-val');
            const outHsl = document.getElementById('hsl-val');
            const outLum = document.getElementById('luminance-val');
            const outContB = document.getElementById('contrast-black');
            const outContW = document.getElementById('contrast-white');
            const sampleOnBlack = document.getElementById('contrast-on-black');
            const sampleOnWhite = document.getElementById('contrast-on-white');

            function setStatus(msg) { statusLine.textContent = msg || ''; }
            if (!('EyeDropper' in window)) { eyedropBtn.disabled = true; eyedropBtn.title = 'このブラウザは画面スポイトに未対応です'; }

            function addImageFromHTMLImageElement(img) {
                if (images.length >= MAX_IMAGES) { setStatus(`最大${MAX_IMAGES}枚まで`); return; }
                const sourceCanvas = document.createElement('canvas');
                const sctx = sourceCanvas.getContext('2d', { willReadFrequently: true });
                sctx.imageSmoothingEnabled = false;
                sourceCanvas.width = img.naturalWidth || img.width;
                sourceCanvas.height = img.naturalHeight || img.height;
                sctx.drawImage(img, 0, 0);
                const item = { id: images.length + 1, img, sourceCanvas, sctx, drawnRect: {}, history: [], currentColor: null, blurHistory: [], originalData: sctx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height) };
                images.push(item);
                renderImageButtons();
                setActiveImage(images.length - 1);
                setStatus(`画像${item.id} を追加`);
            }
            function renderImageButtons() {
                switcher.innerHTML = '';
                images.forEach((it, i) => {
                    const btn = document.createElement('button');
                    btn.className = 'img-chip' + (i === activeIndex ? ' active' : '');
                    btn.textContent = `画像${it.id}`;
                    btn.onclick = () => setActiveImage(i);
                    switcher.appendChild(btn);
                });
            }
            function setActiveImage(index) {
                if (index < 0 || index >= images.length) return;
                isColorAdjusting = false; adjustBase = null;
                activeIndex = index;
                renderImageButtons();
                stageHint.style.display = 'none';
                resizeImageStage();
                const act = getActiveImage();
                if (act) {
                    if (act.currentColor) setCurrentColor(act.currentColor, false); else resetColorOutputs();
                    updateBlurButtons();
                }
                renderHistory();
                setStatus(`画像${act.id} を表示中`);
            }
            function getActiveImage() { return images[activeIndex] ?? null; }
            function loadImageFromFile(file) {
                if (!file.type.startsWith('image/')) { setStatus('画像ファイルを選択'); return; }
                const reader = new FileReader();
                reader.onload = (e) => loadImageFromSrc(e.target.result, false);
                reader.readAsDataURL(file);
            }
            function loadImageFromSrc(src, remote) {
                const img = new Image();
                if (remote) img.crossOrigin = 'anonymous';
                img.onload = () => addImageFromHTMLImageElement(img);
                img.onerror = () => setStatus('画像読み込み失敗（CORS制限の可能性）');
                img.src = src;
            }
            window.resizeImageStage = function() {
                const rect = stage.getBoundingClientRect();
                if (displayCanvas.width !== rect.width || displayCanvas.height !== rect.height) {
                    displayCanvas.width = rect.width;
                    displayCanvas.height = rect.height;
                }
                redrawDisplay();
            }
            function redrawDisplay() {
                dctx.clearRect(0, 0, displayCanvas.width, displayCanvas.height);
                const act = getActiveImage();
                if (!act) return;
                const { width: iw, height: ih } = act.sourceCanvas;
                const { width: sw, height: sh } = displayCanvas;
                const scale = Math.min(sw / iw, sh / ih);
                const dw = iw * scale, dh = ih * scale;
                const dx = (sw - dw) / 2, dy = (sh - dh) / 2;
                act.drawnRect = { dx, dy, dw, dh };
                dctx.imageSmoothingEnabled = true;
                dctx.drawImage(act.sourceCanvas, dx, dy, dw, dh);
            }
            function mapToImagePixel(clientX, clientY) {
                const act = getActiveImage();
                if (!act) return null;
                const rect = displayCanvas.getBoundingClientRect();
                const x = clientX - rect.left, y = clientY - rect.top;
                const { dx, dy, dw, dh } = act.drawnRect;
                if (x < dx || y < dy || x >= dx + dw || y >= dy + dh) return null;
                const nx = (x - dx) / dw, ny = (y - dy) / dh;
                const px = Math.floor(nx * act.sourceCanvas.width);
                const py = Math.floor(ny * act.sourceCanvas.height);
                return { px, py, cx: x, cy: y };
            }
            function readPixel(px, py) {
                const act = getActiveImage();
                if (!act) return null;
                try {
                    const data = act.sctx.getImageData(px, py, 1, 1).data;
                    return { r: data[0], g: data[1], b: data[2], a: data[3] / 255 };
                } catch (e) { setStatus('読取失敗（CORS制限）'); return null; }
            }
            function drawMagnifier(px, py, cx, cy) {
                const act = getActiveImage(); if (!act) return;
                const w = 140, h = 140, size = 21, half = 10;
                const sx = px - half, sy = py - half;
                mctx.clearRect(0,0,w,h); mctx.fillStyle = '#222'; mctx.fillRect(0,0,w,h);
                mctx.drawImage(act.sourceCanvas, sx, sy, size, size, 0, 0, w, h);
                mctx.strokeStyle = 'rgba(255,255,255,0.2)'; mctx.lineWidth = 1;
                const step = w / size;
                for (let i = 1; i < size; i++) { mctx.beginPath(); mctx.moveTo(i*step, 0); mctx.lineTo(i*step, h); mctx.stroke(); mctx.beginPath(); mctx.moveTo(0, i*step); mctx.lineTo(w, i*step); mctx.stroke(); }
                mctx.strokeStyle = '#fff'; mctx.lineWidth = 2;
                mctx.strokeRect(w/2, h/2, 1, 1);
                const rect = stage.getBoundingClientRect();
                magnifierCanvas.style.left = `${Math.min(rect.width-w-10, Math.max(10, cx+20))}px`;
                magnifierCanvas.style.top  = `${Math.min(rect.height-h-10, Math.max(10, cy+20))}px`;
                magnifierCanvas.style.display = 'block';
            }
            function drawBlurMagnifier(px, py, cx, cy) {
                if (!blurMagnifierEnabled.checked) { blurMagnifierCanvas.style.display = 'none'; return; }
                const act = getActiveImage(); if (!act) return;
                const w = 200, h = 200, sourceSize = Math.floor(w / blurZoomLevel), half = Math.floor(sourceSize/2);
                const sx = px - half, sy = py - half;
                bmctx.clearRect(0,0,w,h); bmctx.fillStyle = '#222'; bmctx.fillRect(0,0,w,h);
                bmctx.drawImage(act.sourceCanvas, sx, sy, sourceSize, sourceSize, 0, 0, w, h);
                bmctx.strokeStyle = 'rgba(255, 100, 0, 0.8)'; bmctx.lineWidth = 2;
                bmctx.beginPath(); bmctx.arc(w/2, h/2, (brushSize/2)*blurZoomLevel*(w/sourceSize), 0, Math.PI*2); bmctx.stroke();
                bmctx.strokeStyle = 'rgba(255,255,255,0.5)'; bmctx.lineWidth = 1;
                bmctx.beginPath(); bmctx.moveTo(w/2,0); bmctx.lineTo(w/2,h); bmctx.moveTo(0,h/2); bmctx.lineTo(w,h/2); bmctx.stroke();
                const rect = stage.getBoundingClientRect();
                blurMagnifierCanvas.style.left = `${Math.min(rect.width-w-10, Math.max(10, cx+20))}px`;
                blurMagnifierCanvas.style.top = `${Math.min(rect.height-h-10, Math.max(10, cy-h-20))}px`;
                blurMagnifierCanvas.style.display = 'block';
            }
            function hideMagnifier() { magnifierCanvas.style.display = 'none'; blurMagnifierCanvas.style.display = 'none'; }
            function setToolMode(mode) {
                toolMode = toolMode === mode ? 'none' : mode;
                stage.classList.toggle('picking', toolMode === 'picker');
                stage.classList.toggle('blurring', toolMode === 'blur');
                blurSettingsPanel.style.display = toolMode === 'blur' ? 'flex' : 'none';
                canvasPickerBtn.classList.toggle('active', toolMode === 'picker');
                blurBrushBtn.classList.toggle('active', toolMode === 'blur');
                setStatus(toolMode === 'picker' ? 'クリックで色取得' : toolMode === 'blur' ? 'ドラッグでぼかす' : '');
                if (toolMode === 'none') hideMagnifier();
            }
            function resetColorOutputs() {
                currentSwatch.style.background = '#000';
                currentColorText.textContent = '未取得';
                [outHex, outHexa, outRgb, outHsl, outLum, outContB, outContW].forEach(el => el.textContent = '-');
                sampleOnBlack.style.color = '#fff'; sampleOnWhite.style.color = '#000';
            }
            function setCurrentColor(col, pushHistory = true) {
                if (!col) return;
                globalCurrentColor = col;
                const { r, g, b, a } = col;
                const hex = rgbToHex(r,g,b), hexa = rgbaToHex(r,g,b,a), rgb = toRgbString(r,g,b,a), hsl = toHslString(r,g,b,a);
                const lum = relativeLuminance(r,g,b), contB = contrastRatio(lum, 0), contW = contrastRatio(1, lum);
                currentSwatch.style.background = hexa;
                currentColorText.textContent = `${hex} / ${rgb}`;
                outHex.textContent = hex; outHexa.textContent = hexa; outRgb.textContent = rgb; outHsl.textContent = hsl;
                outLum.textContent = lum.toFixed(4); outContB.textContent = contB.toFixed(2); outContW.textContent = contW.toFixed(2);
                sampleOnBlack.style.color = hexa; sampleOnWhite.style.color = hexa;
                const act = getActiveImage();
                if (act) {
                    act.currentColor = col;
                    if (pushHistory) { act.history.unshift(col); if (act.history.length > 60) act.history.pop(); renderHistory(); }
                }
            }
            function renderHistory() {
                historyContainer.innerHTML = '';
                const act = getActiveImage();
                if (!act?.history.length) return;
                act.history.forEach(c => {
                    const d = document.createElement('button');
                    d.className = 'history-item';
                    d.style.background = rgbaToHex(c.r,c.g,c.b,c.a);
                    d.title = rgbToHex(c.r,c.g,c.b);
                    d.onclick = () => setCurrentColor(c, false);
                    historyContainer.appendChild(d);
                });
            }
            function adjustPointerPosition(clientX, clientY, isTouch) {
                let x = clientX, y = clientY;
                const rect = stage.getBoundingClientRect();
                if (isTouch && touchOffsetEnabled && touchOffsetValue > 0) {
                    y = clientY - touchOffsetValue;
                    offsetLine.style.cssText = `left:${x-rect.left}px; top:${y-rect.top}px; height:${touchOffsetValue}px; display:block;`;
                } else { offsetLine.style.display = 'none'; }
                return { x, y };
            }
            function updatePointerMarker(clientX, clientY, show) {
                if (!show) { pointerMarker.style.display = 'none'; return; }
                const rect = stage.getBoundingClientRect();
                pointerMarker.style.cssText = `left:${clientX-rect.left}px; top:${clientY-rect.top}px; display:block;`;
            }
            function updateBrushPreview(clientX, clientY, show) {
                if (!show || toolMode !== 'blur') { brushPreview.style.display = 'none'; return; }
                const rect = stage.getBoundingClientRect();
                const size = brushSize * 2;
                brushPreview.style.cssText = `width:${size}px; height:${size}px; left:${clientX-rect.left}px; top:${clientY-rect.top}px; display:block;`;
            }
            function applyBlur(px, py) {
                const act = getActiveImage(); if (!act) return;
                const radius = brushSize/2, blurPx = blurStrength;
                const sx = px-radius-blurPx, sy = py-radius-blurPx, sw = radius*2+blurPx*2, sh = sw;
                if (sw <= 0) return;
                const tmp = document.createElement('canvas'); tmp.width = sw; tmp.height = sh;
                const tctx = tmp.getContext('2d');
                tctx.filter = `blur(${blurPx}px)`;
                tctx.drawImage(act.sourceCanvas, sx, sy, sw, sh, 0, 0, sw, sh);
                act.sctx.save();
                act.sctx.beginPath(); act.sctx.arc(px,py,radius,0,Math.PI*2); act.sctx.clip();
                act.sctx.drawImage(tmp, sx, sy);
                act.sctx.restore();
                redrawDisplay();
            }
            function updateBlurButtons() {
                const act = getActiveImage();
                undoBlurBtn.disabled = !(act?.blurHistory.length > 0);
                resetBlurBtn.disabled = !(act?.blurHistory.length > 0);
            }
            function handlePointerStart(clientX, clientY, isTouch) {
                const { x, y } = adjustPointerPosition(clientX, clientY, isTouch);
                updatePointerMarker(x, y, toolMode !== 'none');
                const map = mapToImagePixel(x, y);
                if (!map) return;
                if (toolMode === 'picker') {
                    const pix = readPixel(map.px, map.py);
                    if (pix) { setCurrentColor(pix, true); setStatus('色を取得'); }
                } else if (toolMode === 'blur') {
                    isDrawing = true;
                    const act = getActiveImage();
                    if (act) {
                        act.blurHistory.push(act.sctx.getImageData(0, 0, act.sourceCanvas.width, act.sourceCanvas.height));
                        updateBlurButtons();
                        applyBlur(map.px, map.py);
                        drawBlurMagnifier(map.px, map.py, map.cx, map.cy);
                    }
                }
            }
            function handlePointerMove(clientX, clientY, isTouch) {
                const { x, y } = adjustPointerPosition(clientX, clientY, isTouch);
                updatePointerMarker(x, y, toolMode !== 'none');
                updateBrushPreview(x, y, toolMode === 'blur');
                const map = mapToImagePixel(x, y);
                if (!map) { hideMagnifier(); return; }
                if (toolMode === 'picker') {
                    const pix = readPixel(map.px, map.py);
                    if (pix) drawMagnifier(map.px, map.py, map.cx, map.cy);
                } else if (toolMode === 'blur') {
                    if (isDrawing) applyBlur(map.px, map.py);
                    drawBlurMagnifier(map.px, map.py, map.cx, map.cy);
                }
            }
            function handlePointerEnd() { isDrawing = false; pointerMarker.style.display = 'none'; offsetLine.style.display = 'none'; brushPreview.style.display = 'none'; if (toolMode==='blur') blurMagnifierCanvas.style.display='none'; }
            fileInput.onchange = (e) => { const files = Array.from(e.target.files); if (!files.length) return; const room = MAX_IMAGES - images.length; files.slice(0, room).forEach(loadImageFromFile); fileInput.value = ''; };
            urlBtn.onclick = () => { const url = urlInput.value.trim(); if (!url || images.length >= MAX_IMAGES) return; loadImageFromSrc(url, true); };
            stage.ondragover = (e) => { e.preventDefault(); stageOverlay.style.display = 'block'; };
            stage.ondragleave = () => { stageOverlay.style.display = 'none'; };
            stage.ondrop = (e) => { e.preventDefault(); stageOverlay.style.display = 'none'; const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/')); if (!files.length) return; const room = MAX_IMAGES - images.length; files.slice(0, room).forEach(loadImageFromFile); };
            eyedropBtn.onclick = async () => { setToolMode('none'); try { const res = await new window.EyeDropper().open(); setCurrentColor(hexToRgba(res.sRGBHex), true); setStatus('画面スポイトで取得'); } catch { setStatus('画面スポイトをキャンセル'); } };
            canvasPickerBtn.onclick = () => setToolMode('picker');
            blurBrushBtn.onclick = () => setToolMode('blur');
            brushSizeInput.oninput = (e) => { brushSize = +e.target.value; brushSizeDisplay.textContent = brushSize; };
            blurStrengthInput.oninput = (e) => { blurStrength = +e.target.value; blurStrengthDisplay.textContent = blurStrength; };
            blurZoomInput.oninput = (e) => { blurZoomLevel = +e.target.value; blurZoomDisplay.textContent = blurZoomLevel; };
            undoBlurBtn.onclick = () => { const act = getActiveImage(); if (!act?.blurHistory.length) return; act.sctx.putImageData(act.blurHistory.pop(), 0, 0); redrawDisplay(); updateBlurButtons(); setStatus('ボカシを元に戻した'); };
            resetBlurBtn.onclick = () => { const act = getActiveImage(); if (!act?.originalData) return; act.sctx.putImageData(act.originalData, 0, 0); act.blurHistory = []; redrawDisplay(); updateBlurButtons(); setStatus('ボカシをリセット'); };
            touchOffsetEnabledCheck.onchange = (e) => { touchOffsetEnabled = e.target.checked; };
            touchOffsetValueInput.onchange = (e) => { touchOffsetValue = +e.target.value || 0; };
            function beginColorAdjustIfNeeded() { const act = getActiveImage(); if (!act) return null; if (!isColorAdjusting) { adjustBase = act.sctx.getImageData(0,0,act.sourceCanvas.width,act.sourceCanvas.height); isColorAdjusting = true; } return { act, base: adjustBase }; }
            function applyColorAdjustPreview() { const ctx = beginColorAdjustIfNeeded(); if (!ctx) return; const { act, base } = ctx; const sFactor = +satRange.value/100, bFactor = +briRange.value/100; satDisplay.textContent = (sFactor*100).toFixed(0); briDisplay.textContent = (bFactor*100).toFixed(0); const bd = base.data, out = act.sctx.createImageData(base.width, base.height), od = out.data; for (let i = 0; i < bd.length; i+=4) { const hsl=rgbToHsl(bd[i],bd[i+1],bd[i+2]), s=Math.max(0,Math.min(1,hsl.s*sFactor)), l=Math.max(0,Math.min(1,hsl.l*bFactor)), rgb=hslToRgb(hsl.h,s,l); od[i]=rgb.r; od[i+1]=rgb.g; od[i+2]=rgb.b; od[i+3]=bd[i+3]; } act.sctx.putImageData(out,0,0); redrawDisplay(); }
            function commitColorAdjust() { if (!isColorAdjusting || !adjustBase) return; const act = getActiveImage(); if (act) { act.blurHistory.push(adjustBase); updateBlurButtons(); setStatus('色調整を適用'); } isColorAdjusting = false; adjustBase = null; }
            satRange.oninput = briRange.oninput = applyColorAdjustPreview;
            satRange.onchange = briRange.onchange = commitColorAdjust;
            resetAdjustBtn.onclick = () => { satRange.value=100; briRange.value=100; satDisplay.textContent='100'; briDisplay.textContent='100'; if (isColorAdjusting && adjustBase) { getActiveImage()?.sctx.putImageData(adjustBase,0,0); redrawDisplay(); } isColorAdjusting = false; adjustBase = null; setStatus('色調整をリセット'); };
            displayCanvas.onmousedown = (e) => handlePointerStart(e.clientX, e.clientY, false);
            displayCanvas.onmousemove = (e) => handlePointerMove(e.clientX, e.clientY, false);
            displayCanvas.onmouseup = displayCanvas.onmouseleave = handlePointerEnd;
            displayCanvas.ontouchstart = (e) => { if (e.touches.length === 1) { e.preventDefault(); handlePointerStart(e.touches[0].clientX, e.touches[0].clientY, true); }};
            displayCanvas.ontouchmove = (e) => { if (e.touches.length === 1) { e.preventDefault(); handlePointerMove(e.touches[0].clientX, e.touches[0].clientY, true); }};
            displayCanvas.ontouchend = handlePointerEnd;
            new ResizeObserver(() => resizeImageStage()).observe(stage);
            document.querySelectorAll('.copy-btn').forEach(btn => btn.onclick = async () => { const id = btn.dataset.copyTarget; const el = document.getElementById(id); if (!el) return; try { await navigator.clipboard.writeText(el.textContent.trim()); setStatus('コピーしました'); } catch { setStatus('コピー失敗'); } });
            setStatus('画像を読み込むとツールが使えます');
            
            // ★★★ カラー編集タブのロジック ★★★
            const colorlab = {
                input: document.getElementById('colorlab-input'),
                validBadge: document.getElementById('colorlab-valid'),
                swatch: document.getElementById('colorlab-swatch'),
                lockLightness: document.getElementById('colorlab-lock-lightness'),
                hue: { slider: document.getElementById('colorlab-hue'), val: document.getElementById('colorlab-hue-val') },
                sat: { slider: document.getElementById('colorlab-sat'), val: document.getElementById('colorlab-sat-val') },
                light: { slider: document.getElementById('colorlab-light'), val: document.getElementById('colorlab-light-val') },
                alpha: { slider: document.getElementById('colorlab-alpha'), val: document.getElementById('colorlab-alpha-val') },
                btnReset: document.getElementById('colorlab-btn-reset'),
                btnPull: document.getElementById('colorlab-btn-pull'),
                btnSend: document.getElementById('colorlab-btn-send'),
                out: {
                    hex: document.getElementById('colorlab-hex-val'),
                    hexa: document.getElementById('colorlab-hexa-val'),
                    rgb: document.getElementById('colorlab-rgb-val'),
                    hsl: document.getElementById('colorlab-hsl-val'),
                    lum: document.getElementById('colorlab-luminance-val'),
                    contB: document.getElementById('colorlab-contrast-black'),
                    contW: document.getElementById('colorlab-contrast-white'),
                    sampleB: document.getElementById('colorlab-on-black'),
                    sampleW: document.getElementById('colorlab-on-white'),
                },
                state: { base: null, current: null, hsl: null }
            };

            function parseCssColor(str) {
                const d = document.createElement('div');
                d.style.color = str;
                document.body.appendChild(d);
                const comp = window.getComputedStyle(d).color;
                document.body.removeChild(d);
                if (!comp || comp === 'rgba(0, 0, 0, 0)' && str !== 'transparent') return null;
                const match = comp.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
                if (!match) return null;
                return { r: +match[1], g: +match[2], b: +match[3], a: match[4] === undefined ? 1 : +match[4] };
            }

            function updateColorlabFromInput() {
                const val = colorlab.input.value.trim();
                if (!val) { resetColorlabUI(); return; }
                const parsed = parseCssColor(val);
                if (!parsed) {
                    colorlab.validBadge.textContent = '不正';
                    colorlab.validBadge.className = 'validity-badge ng';
                    return;
                }
                colorlab.validBadge.textContent = 'OK';
                colorlab.validBadge.className = 'validity-badge ok';
                colorlab.state.base = parsed;
                updateColorlabState(parsed);
            }

            function updateColorlabFromSliders() {
                const h = +colorlab.hue.slider.value;
                const s = +colorlab.sat.slider.value / 100;
                const l = +colorlab.light.slider.value / 100;
                const a = +colorlab.alpha.slider.value / 100;

                let useH = h, useS = s;
                if (colorlab.lockLightness.checked && colorlab.state.hsl) {
                    useH = colorlab.state.hsl.h;
                    useS = colorlab.state.hsl.s;
                }

                const rgb = hslToRgb(useH, useS, l);
                updateColorlabState({ ...rgb, a });
            }

            function updateColorlabState(rgb_a) {
                colorlab.state.current = rgb_a;
                colorlab.state.hsl = rgbToHsl(rgb_a.r, rgb_a.g, rgb_a.b);
                colorlab.state.hsl.a = rgb_a.a;
                updateColorlabUI();
            }

            function updateColorlabUI() {
                const { r, g, b, a } = colorlab.state.current;
                const { h, s, l } = colorlab.state.hsl;
                
                // スライダー更新
                colorlab.hue.slider.value = h;
                colorlab.hue.val.textContent = h.toFixed(0);
                colorlab.sat.slider.value = s * 100;
                colorlab.sat.val.textContent = `${(s * 100).toFixed(0)}%`;
                colorlab.light.slider.value = l * 100;
                colorlab.light.val.textContent = `${(l * 100).toFixed(0)}%`;
                colorlab.alpha.slider.value = a * 100;
                colorlab.alpha.val.textContent = `${(a * 100).toFixed(0)}%`;
                
                // スウォッチ
                const hexa = rgbaToHex(r, g, b, a);
                colorlab.swatch.style.backgroundColor = hexa;

                // 出力
                colorlab.out.hex.textContent = rgbToHex(r, g, b);
                colorlab.out.hexa.textContent = hexa;
                colorlab.out.rgb.textContent = toRgbString(r, g, b, a);
                colorlab.out.hsl.textContent = toHslString(r, g, b, a);
                const lum = relativeLuminance(r, g, b);
                colorlab.out.lum.textContent = lum.toFixed(4);
                colorlab.out.contB.textContent = contrastRatio(lum, 0).toFixed(2);
                colorlab.out.contW.textContent = contrastRatio(1, lum).toFixed(2);
                colorlab.out.sampleB.style.color = hexa;
                colorlab.out.sampleW.style.color = hexa;
            }

            function resetColorlabUI() {
                colorlab.validBadge.textContent = '未入力';
                colorlab.validBadge.className = 'validity-badge';
                colorlab.swatch.style.backgroundColor = 'transparent';
                ['hex','hexa','rgb','hsl','lum','contB','contW'].forEach(k => colorlab.out[k].textContent = '-');
            }

            colorlab.input.addEventListener('change', updateColorlabFromInput);
            [colorlab.hue.slider, colorlab.sat.slider, colorlab.light.slider, colorlab.alpha.slider].forEach(s => {
                s.addEventListener('input', updateColorlabFromSliders);
            });
            colorlab.lockLightness.addEventListener('change', () => {
                const locked = colorlab.lockLightness.checked;
                colorlab.hue.slider.disabled = locked;
                colorlab.sat.slider.disabled = locked;
            });
            colorlab.btnReset.addEventListener('click', () => {
                if (colorlab.state.base) updateColorlabState(colorlab.state.base);
            });
            colorlab.btnPull.addEventListener('click', () => {
                if (globalCurrentColor) {
                    colorlab.input.value = toRgbString(globalCurrentColor.r, globalCurrentColor.g, globalCurrentColor.b, globalCurrentColor.a);
                    updateColorlabFromInput();
                } else {
                    alert('画像タブで先に色を取得してください。');
                }
            });
            colorlab.btnSend.addEventListener('click', () => {
                if (colorlab.state.current) {
                    globalCurrentColor = colorlab.state.current;
                    alert('色を「彩色モード」に送りました。\n「プレビュー・変更」タブで使えます。');
                }
            });

            // 初期化
            colorlab.input.value = '#007acc';
            updateColorlabFromInput();
            colorlab.hue.slider.disabled = true;
            colorlab.sat.slider.disabled = true;


            // =========== 色変換ユーティリティ ===========
            function clamp01(x) { return Math.min(1, Math.max(0, x)); }
            function pad2(n) { return Math.round(n).toString(16).padStart(2, '0').toUpperCase(); }
            function rgbToHex(r, g, b) { return '#' + pad2(r) + pad2(g) + pad2(b); }
            function rgbaToHex(r, g, b, a = 1) { return '#' + pad2(r) + pad2(g) + pad2(b) + pad2(a * 255); }
            function hexToRgba(hex) {
                let h = hex.replace('#', '').trim();
                if (h.length === 3) h = h[0]+h[0]+h[1]+h[1]+h[2]+h[2];
                if (h.length >= 6) {
                    const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16);
                    const a = h.length === 8 ? parseInt(h.slice(6,8),16)/255 : 1;
                    return { r, g, b, a };
                }
                return { r:0,g:0,b:0,a:1 };
            }
            function toRgbString(r, g, b, a = 1) {
                const aa = clamp01(a);
                if (aa < 1) return `rgb(${r} ${g} ${b} / ${+(aa * 100).toFixed(1)}%)`;
                return `rgb(${r} ${g} ${b})`;
            }
            function rgbToHsl(r, g, b) {
                r /= 255, g /= 255, b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h = 0, s = 0, l = (max + min) / 2;
                if (max !== min) {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    h *= 60;
                }
                return { h, s, l };
            }
            function hslToRgb(h, s, l) {
                let r, g, b;
                if (s === 0) r = g = b = l;
                else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1; if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, (h/360) + 1/3);
                    g = hue2rgb(p, q, h/360);
                    b = hue2rgb(p, q, (h/360) - 1/3);
                }
                return { r: r * 255, g: g * 255, b: b * 255 };
            }
            function toHslString(r, g, b, a = 1) {
                const hsl = rgbToHsl(r, g, b);
                const hh = Math.round(hsl.h), ss = Math.round(hsl.s*100), ll = Math.round(hsl.l*100);
                const aa = clamp01(a);
                if (aa < 1) return `hsl(${hh} ${ss}% ${ll}% / ${+(aa * 100).toFixed(1)}%)`;
                return `hsl(${hh} ${ss}% ${ll}%)`;
            }
            function srgbToLinear(c) { c /= 255; return c <= 0.04045 ? c/12.92 : Math.pow((c+0.055)/1.055, 2.4); }
            function relativeLuminance(r, g, b) { return 0.2126*srgbToLinear(r) + 0.7152*srgbToLinear(g) + 0.0722*srgbToLinear(b); }
            function contrastRatio(l1, l2) { const L1 = Math.max(l1,l2), L2 = Math.min(l1,l2); return (L1 + 0.05) / (L2 + 0.05); }

        });
    </script>
</body>
</html>
