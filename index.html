<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Color Canvas - ライブWebエディタ</title>

    <!-- CodeMirror（CDN） -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/material-darker.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>

    <style>
        /* 全体 */
        :root {
            --bg: #1e1e1e;
            --panel: #252526;
            --panel-2: #2d2d2d;
            --panel-3: #333;
            --border-1: #444;
            --accent: #007acc;
            --text: #d4d4d4;
            --muted: #aaaaaa;
            --ok: #7bd88f;
            --ng: #f26d6d;
            --shadow: rgba(0,0,0,0.35);
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            background-color: var(--panel-3);
            padding: 10px 20px;
            font-size: 1.2em;
            font-weight: bold;
            border-bottom: 2px solid var(--accent);
        }

        /* 上位タブ（編集 / プレビュー / 画像カラー分析） */
        .main-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }
        .top-tabs {
            display: flex;
            background-color: var(--bg);
            border-bottom: 2px solid var(--border-1);
        }
        .top-tab-button {
            padding: 10px 16px;
            border: none;
            background-color: var(--panel-2);
            color: #ccc;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .top-tab-button + .top-tab-button {
            border-left: 1px solid var(--border-1);
        }
        .top-tab-button.active {
            background-color: var(--panel-3);
            color: white;
            border-bottom: 3px solid var(--accent);
        }

        .page-container {
            position: relative;
            flex: 1;
            min-height: 0;
        }
        .tab-page {
            position: absolute;
            inset: 0;
            display: none;
        }
        .tab-page.active {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        /* パネル共通 */
        .panel-header {
            background-color: var(--panel-3);
            padding: 8px 12px;
            font-weight: bold;
            border-bottom: 1px solid var(--border-1);
        }
        .panel {
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
        }

        /* コードエディタ */
        .code-tabs {
            display: flex;
            background-color: var(--bg);
            border-bottom: 1px solid var(--border-1);
        }
        .tab-button {
            padding: 10px 15px;
            border: none;
            background-color: var(--panel-2);
            color: #ccc;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .tab-button.active {
            background-color: var(--panel-3);
            color: white;
            border-bottom: 3px solid var(--accent);
        }
        .editor-container {
            flex: 1;
            position: relative;
            min-height: 0;
        }
        .CodeMirror {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100% !important;
            font-size: 14px;
        }
        .editor-wrapper {
            display: none;
            height: 100%;
        }
        .editor-wrapper.active {
            display: block;
        }

        /* プレビュー・変更（左右分割） */
        .split-container {
            display: flex;
            flex: 1;
            min-height: 0;
        }
        .split-left, .split-right {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        .split-left {
            flex: 1 1 55%;
            border-right: 2px solid var(--border-1);
            min-width: 320px;
        }
        .split-right {
            flex: 1 1 45%;
            min-width: 320px;
        }
        .frame-wrap {
            flex: 1;
            min-height: 0;
        }
        #preview-frame {
            width: 100%;
            height: 100%;
            border: none;
            background-color: #fff;
        }

        /* インスペクター（プレビュー・変更タブ右側） */
        .inspector-body {
            flex: 1;
            background-color: var(--panel);
            padding: 15px;
            overflow-y: auto;
        }
        .inspector-item {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .inspector-item label {
            min-width: 120px;
            font-size: 0.9em;
            color: var(--muted);
        }
        .inspector-item input[type="text"],
        .inspector-item textarea {
            background-color: #3c3c3c;
            border: 1px solid #555;
            color: #f0f0f0;
            padding: 6px 8px;
            border-radius: 3px;
            flex: 1 1 240px;
        }
        .inspector-item textarea {
            min-height: 60px;
            resize: vertical;
        }
        .color-swatch {
            width: 18px;
            height: 18px;
            border: 1px solid #555;
            border-radius: 3px;
            background: transparent;
        }
        .validity-badge {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
            border: 1px solid #555;
            color: #ddd;
        }
        .validity-badge.ok { border-color: #2e7d32; color: var(--ok); }
        .validity-badge.ng { border-color: #8e2a2a; color: var(--ng); }
        .inspector-actions { display: inline-flex; gap: 6px; align-items: center; }
        .btn {
            background: var(--panel-2);
            border: 1px solid #555;
            color: #eee;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
        }
        .btn:hover { background: #3a3a3a; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* 画像カラー分析タブ */
        .img-toolbar {
            display: flex; gap: 8px; align-items: center;
            padding: 8px 12px; background: var(--panel-2); border-bottom: 1px solid var(--border-1);
            flex-wrap: wrap;
        }
        .img-toolbar input[type="text"] {
            background: #3c3c3c; border: 1px solid #555; color: #f0f0f0; padding: 6px 8px; border-radius: 3px;
            min-width: 200px; flex: 1 1 200px;
        }
        .img-toolbar input[type="file"] { color: #ddd; }
        .img-switcher {
            display: flex; gap: 6px; align-items: center; flex-wrap: wrap;
            padding: 8px 12px; background: var(--panel-2); border-bottom: 1px solid var(--border-1);
        }
        .img-chip {
            padding: 4px 10px; border: 1px solid #555; border-radius: 16px; background: #2f2f2f; color: #ddd; cursor: pointer;
        }
        .img-chip.active {
            background: var(--accent); border-color: var(--accent); color: #fff;
        }
        .img-stage {
            position: relative; flex: 1; min-height: 0;
            background: conic-gradient(#eee 25%, #fff 0 50%, #eee 0 75%, #fff 0) 0 0 / 16px 16px;
        }
        #image-canvas {
            width: 100%; height: 100%; display: block; background: transparent;
        }
        #magnifier-canvas {
            position: absolute; width: 140px; height: 140px;
            border: 1px solid #666; border-radius: 6px; box-shadow: 0 6px 18px var(--shadow);
            display: none; pointer-events: none; background: #111;
        }
        .img-stage.picking #image-canvas { cursor: crosshair; }
        .img-stage.blurring #image-canvas { cursor: none; } /* カスタムカーソル用 */
        .stage-hint {
            position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
            color: #ccc; font-size: 0.95em; text-align: center; padding: 8px; pointer-events: none;
        }
        .stage-overlay {
            position: absolute; inset: 0; border: 2px dashed #666; border-radius: 8px; pointer-events: none; margin: 8px;
        }
        .panel-section-title { font-weight: bold; margin: 12px 0 6px; color: #fff; }
        .current-color { display: flex; align-items: center; gap: 10px; }
        .swatch-large { width: 64px; height: 64px; border: 1px solid #555; border-radius: 6px; background: #000; }
        .kv-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; flex-wrap: wrap; }
        .kv-row code {
            background: #2a2a2a; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; color: #eee; word-break: break-all;
        }
        .copy-btn { padding: 4px 8px; }
        .contrast-box { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 6px; }
        .contrast-sample { height: 48px; display: flex; align-items: center; justify-content: center; border-radius: 6px; border: 1px solid #555; font-weight: 600; }
        .history-list { display: flex; flex-wrap: wrap; gap: 8px; }
        .history-item { width: 28px; height: 28px; border: 1px solid #555; border-radius: 4px; cursor: pointer; }
        .status-line { font-size: 0.85em; color: #ccc; padding: 4px 12px; border-top: 1px solid #444; background: #2b2b2b; }
        .note { color: #bbb; font-size: 0.85em; }

        /* 新機能：タッチオフセット */
        .touch-offset-group {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        .touch-offset-group input[type="number"] { padding: 2px 4px; width: 60px; }

        /* 新機能：ブラシ設定 */
        .brush-settings {
            padding: 8px 12px;
            background: var(--panel-2);
            border-bottom: 1px solid var(--border-1);
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        .brush-settings label { display: flex; align-items: center; gap: 6px; }
        .brush-settings input[type="range"] { width: 120px; }

        /* 新機能：ポインターマーカー */
        #pointer-marker {
            position: absolute;
            width: 24px;
            height: 24px;
            border: 2px solid #00ff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        #pointer-marker::before,
        #pointer-marker::after {
            content: '';
            position: absolute;
            background: #00ff00;
        }
        #pointer-marker::before {
            width: 2px;
            height: 8px;
            left: 50%;
            top: -10px;
            transform: translateX(-50%);
        }
        #pointer-marker::after {
            width: 8px;
            height: 2px;
            left: -10px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* 新機能：ブラシプレビュー */
        #brush-preview {
            position: absolute;
            border: 2px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            display: none;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.5);
            transform: translate(-50%, -50%);
        }

        /* 新機能：オフセットライン */
        #offset-line {
            position: absolute;
            border-left: 1px dashed rgba(255,255,255,0.5);
            pointer-events: none;
            z-index: 998;
            display: none;
            transform-origin: top left;
        }
    </style>
</head>
<body>
    <header>Code Color Canvas</header>

    <main class="main-container">
        <!-- 上位タブ -->
        <div class="top-tabs">
            <button class="top-tab-button active" onclick="showMainTab('code')">コード編集</button>
            <button class="top-tab-button" onclick="showMainTab('preview')">プレビュー・変更</button>
            <button class="top-tab-button" onclick="showMainTab('image')">画像カラー分析</button>
        </div>

        <div class="page-container">
            <!-- コード編集タブ -->
            <section id="code-page" class="tab-page active">
                <div class="panel code-panel">
                    <div class="panel-header">コード編集</div>
                    <div class="code-tabs">
                        <button class="tab-button active" onclick="showEditor('html')">HTML</button>
                        <button class="tab-button" onclick="showEditor('css')">CSS</button>
                        <button class="tab-button" onclick="showEditor('js')">JavaScript</button>
                    </div>
                    <div class="editor-container">
                        <div id="html-editor-wrapper" class="editor-wrapper active">
                            <textarea id="html-code"></textarea>
                        </div>
                        <div id="css-editor-wrapper" class="editor-wrapper">
                            <textarea id="css-code"></textarea>
                        </div>
                        <div id="js-editor-wrapper" class="editor-wrapper">
                            <textarea id="js-code"></textarea>
                        </div>
                    </div>
                </div>
            </section>

            <!-- プレビュー・変更タブ（左右分割） -->
            <section id="preview-page" class="tab-page">
                <div class="split-container">
                    <div class="split-left">
                        <div class="panel-header">プレビュー</div>
                        <div class="frame-wrap">
                            <iframe id="preview-frame"></iframe>
                        </div>
                    </div>
                    <div class="split-right">
                        <div class="panel-header">インスペクター</div>
                        <div class="inspector-body">
                            <p id="inspector-placeholder">プレビュー内の要素をクリックすると、ここでテキストやスタイルを編集できます。</p>
                            <div id="inspector-ui" style="display: none;">
                                <div class="inspector-item">
                                    <label>選択中の要素</label>
                                    <b id="selected-element-selector"></b>
                                </div>

                                <!-- テキスト編集 -->
                                <div class="inspector-item">
                                    <label for="inspector-text">テキスト</label>
                                    <textarea id="inspector-text" placeholder="選択した要素のテキストを編集"></textarea>
                                    <div class="inspector-actions">
                                        <label style="display:inline-flex; align-items:center; gap:6px; color:#ccc; font-size: 0.9em;">
                                            <input type="checkbox" id="inspector-text-as-html"> HTMLとして編集
                                        </label>
                                        <button class="btn" id="apply-text">適用</button>
                                    </div>
                                </div>

                                <!-- テキスト色 -->
                                <div class="inspector-item">
                                    <label for="inspector-color">テキスト色</label>
                                    <input type="text" id="inspector-color" placeholder="例: #ff8800, rgb(255 136 0 / 80%), hsl(30 100% 50%), rebeccapurple, color(display-p3 1 0.5 0)">
                                    <span class="color-swatch" id="swatch-color"></span>
                                    <span class="validity-badge" id="valid-color">未入力</span>
                                    <div class="inspector-actions">
                                        <button class="btn" id="apply-color" disabled>適用</button>
                                        <button class="btn" id="undo-color" disabled>元に戻す</button>
                                        <button class="btn" id="redo-color" disabled>やり直す</button>
                                    </div>
                                </div>

                                <!-- 背景色 -->
                                <div class="inspector-item">
                                    <label for="inspector-bg">背景色</label>
                                    <input type="text" id="inspector-bg" placeholder="例: transparent, #222, rgba(0 0 0 / .4), lch(50 60 40)">
                                    <span class="color-swatch" id="swatch-bg"></span>
                                    <span class="validity-badge" id="valid-bg">未入力</span>
                                    <div class="inspector-actions">
                                        <button class="btn" id="apply-bg" disabled>適用</button>
                                        <button class="btn" id="undo-bg" disabled>元に戻す</button>
                                        <button class="btn" id="redo-bg" disabled>やり直す</button>
                                    </div>
                                </div>

                                <!-- ボックス系 -->
                                <div class="inspector-item">
                                    <label for="inspector-padding">パディング</label>
                                    <input type="text" id="inspector-padding" placeholder="例: 10px / 8px 12px / 1rem 2rem">
                                </div>
                                <div class="inspector-item">
                                    <label for="inspector-margin">マージン</label>
                                    <input type="text" id="inspector-margin" placeholder="例: 10px auto / 0 16px">
                                </div>
                                <div class="inspector-item">
                                    <label for="inspector-fontSize">フォントサイズ</label>
                                    <input type="text" id="inspector-fontSize" placeholder="例: 16px / 1.2rem / clamp(14px, 2vw, 20px)">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- 画像カラー分析タブ（左右分割） -->
            <section id="image-page" class="tab-page">
                <div class="split-container">
                    <!-- 左：画像 -->
                    <div class="split-left">
                        <div class="panel-header">画像</div>
                        <div class="img-toolbar">
                            <input type="file" id="img-file" accept="image/*" multiple>
                            <input type="text" id="img-url" placeholder="画像URL（CORS対応のもの）">
                            <button class="btn" id="btn-load-url">読込</button>
                            <button class="btn" id="btn-eyedropper" title="対応ブラウザのみ">画面スポイト</button>
                            <button class="btn" id="btn-canvas-picker">キャンバススポイト</button>
                            <button class="btn" id="btn-blur-brush">ボカシブラシ</button>
                            <div class="touch-offset-group">
                                <label><input type="checkbox" id="touch-offset-enabled" checked>タッチオフセット</label>
                                <input type="number" id="touch-offset-value" value="40" min="0" max="200">
                                <span>px</span>
                            </div>
                        </div>
                        <div class="brush-settings" id="blur-brush-settings" style="display: none;">
                            <label>ブラシサイズ: <span id="brush-size-display">20</span>px</label>
                            <input type="range" id="brush-size" min="5" max="100" value="20">
                            <label>ボカシ強度: <span id="blur-strength-display">5</span></label>
                            <input type="range" id="blur-strength" min="1" max="20" value="5">
                            <button class="btn" id="btn-undo-blur" disabled>元に戻す</button>
                            <button class="btn" id="btn-reset-blur" disabled>リセット</button>
                        </div>
                        <div class="img-switcher" id="img-switcher"></div>
                        <div class="img-stage" id="image-stage">
                            <canvas id="image-canvas"></canvas>
                            <canvas id="magnifier-canvas" width="140" height="140"></canvas>
                            <div class="stage-hint" id="stage-hint">画像を読み込むか、ここにドラッグ＆ドロップしてください（複数可）</div>
                            <div class="stage-overlay" id="stage-overlay" style="display:none;"></div>
                        </div>
                        <div class="status-line" id="img-status"></div>
                    </div>

                    <!-- 右：分析結果 -->
                    <div class="split-right">
                        <div class="panel-header">カラー分析</div>
                        <div class="inspector-body" id="image-inspector">
                            <div class="panel-section-title">現在の色</div>
                            <div class="current-color">
                                <div class="swatch-large" id="current-swatch"></div>
                                <div id="current-color-text">未取得</div>
                            </div>

                            <div class="panel-section-title">表記</div>
                            <div class="kv-row"><label style="min-width:80px;">HEX</label><code id="hex-val">-</code><button class="btn copy-btn" data-copy-target="hex-val">コピー</button></div>
                            <div class="kv-row"><label style="min-width:80px;">HEXA</label><code id="hexa-val">-</code><button class="btn copy-btn" data-copy-target="hexa-val">コピー</button></div>
                            <div class="kv-row"><label style="min-width:80px;">RGB(A)</label><code id="rgb-val">-</code><button class="btn copy-btn" data-copy-target="rgb-val">コピー</button></div>
                            <div class="kv-row"><label style="min-width:80px;">HSL(A)</label><code id="hsl-val">-</code><button class="btn copy-btn" data-copy-target="hsl-val">コピー</button></div>

                            <div class="panel-section-title">視認性</div>
                            <div class="kv-row"><label style="min-width:120px;">相対輝度</label><code id="luminance-val">-</code></div>
                            <div class="kv-row"><label style="min-width:120px;">コントラスト比</label>
                                <div>対黒: <code id="contrast-black">-</code></div>
                                <div>対白: <code id="contrast-white">-</code></div>
                            </div>
                            <div class="contrast-box">
                                <div class="contrast-sample" id="contrast-on-black" style="background:#000;color:#fff;">サンプル</div>
                                <div class="contrast-sample" id="contrast-on-white" style="background:#fff;color:#000;">サンプル</div>
                            </div>

                            <div class="panel-section-title">履歴（画像ごとに保存）</div>
                            <div class="history-list" id="history-list"></div>
                            <p class="note">画面スポイトはChrome/Edgeなどで使用可能です。URL読み込みはCORS対応の画像のみキャンバス内スポイトが動作します（ローカルファイルはOK）。</p>
                        </div>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- グローバル（プレビュー・変更タブ関連） ---
            let selectedElement = null;
            let lastHighlightedElement = null;
            let lastSelectedSelectorPath = null; // プレビュー更新後の選択復元用

            // 色の履歴（セレクタごと／プロパティごと）: Undo/Redo スタック
            // Map<string, { color: {undo:string[], redo:string[]}, backgroundColor: {undo:string[], redo:string[]} }>
            const colorHistory = new Map();
            function getHistory(selector) {
                if (!colorHistory.has(selector)) {
                    colorHistory.set(selector, {
                        color: { undo: [], redo: [] },
                        backgroundColor: { undo: [], redo: [] }
                    });
                }
                return colorHistory.get(selector);
            }

            // --- CodeMirror 初期化 ---
            const htmlEditor = CodeMirror.fromTextArea(document.getElementById('html-code'), {
                mode: 'xml',
                htmlMode: true,
                theme: 'material-darker',
                lineNumbers: true,
            });
            const cssEditor = CodeMirror.fromTextArea(document.getElementById('css-code'), {
                mode: 'css',
                theme: 'material-darker',
                lineNumbers: true,
            });
            const jsEditor = CodeMirror.fromTextArea(document.getElementById('js-code'), {
                mode: 'javascript',
                theme: 'material-darker',
                lineNumbers: true,
            });

            // --- 初期コード（HTMLは<body>内に入る想定） ---
            const initialHTML = `<div class="container">
  <h1 id="main-title">Code Color Canvasへようこそ！</h1>
  <p>ここにあるテキストやスタイルを自由に編集できます。</p>
  <button id="action-btn">クリック</button>
</div>`;
            const initialCSS = `/* ページ全体のスタイル */
html, body {
  height: 100%;
}
body {
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
  background-color: #f0f0f0;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 0;
}

.container {
  text-align: center;
  padding: 40px;
  background-color: white;
  border-radius: 12px;
  box-shadow: 0 6px 16px rgba(0,0,0,0.12);
}

#main-title {
  color: #333;
  margin: 0 0 10px 0;
}

#action-btn {
  background-color: #007acc;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 16px;
}`;
            const initialJS = `document.getElementById('action-btn')?.addEventListener('click', (e) => {
  alert('ボタンがクリックされました！');
});`;

            htmlEditor.setValue(initialHTML);
            cssEditor.setValue(initialCSS);
            jsEditor.setValue(initialJS);

            // --- 上位タブの切替 ---
            window.showMainTab = function(name) {
                document.querySelectorAll('.top-tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-page').forEach(p => p.classList.remove('active'));
                document.querySelector(`.top-tab-button[onclick="showMainTab('${name}')"]`).classList.add('active');
                document.getElementById(name === 'code' ? 'code-page' : name === 'preview' ? 'preview-page' : 'image-page').classList.add('active');

                if (name === 'code') {
                    htmlEditor.refresh(); cssEditor.refresh(); jsEditor.refresh();
                } else if (name === 'image') {
                    if (typeof resizeImageStage === 'function') resizeImageStage();
                }
            };

            // --- サブタブ（HTML/CSS/JS） ---
            window.showEditor = function(editorName) {
                document.querySelectorAll('.editor-wrapper').forEach(w => w.classList.remove('active'));
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                document.getElementById(`${editorName}-editor-wrapper`).classList.add('active');
                document.querySelector(`.tab-button[onclick="showEditor('${editorName}')"]`).classList.add('active');
                if (editorName === 'html') htmlEditor.refresh();
                if (editorName === 'css') cssEditor.refresh();
                if (editorName === 'js') jsEditor.refresh();
            };

            // --- プレビュー更新 ---
            function updatePreview() {
                const iframe = document.getElementById('preview-frame');
                const doc = iframe.contentDocument || iframe.contentWindow.document;

                const htmlCode = htmlEditor.getValue();
                const cssCode = cssEditor.getValue();
                const jsCode = jsEditor.getValue();

                doc.open();
                doc.write(`<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>${cssCode}</style>
</head>
<body>
${htmlCode}
<script>(function(){\n${jsCode}\n})();<\/script>
</body>
</html>`);
                doc.close();

                setupInspectorListeners();
                if (!restoreSelection()) {
                    selectedElement = null;
                    lastHighlightedElement = null;
                    showInspectorPlaceholder();
                }
            }
            htmlEditor.on('change', updatePreview);
            cssEditor.on('change', updatePreview);
            jsEditor.on('change', updatePreview);

            // --- インスペクター（プレビュー・変更） ---
            function setupInspectorListeners() {
                const iframe = document.getElementById('preview-frame');
                const pdoc = iframe.contentDocument || iframe.contentWindow.document;
                const pbody = pdoc && pdoc.body;
                if (!pbody) return;
                pbody.addEventListener('click', (e) => {
                    e.preventDefault(); e.stopPropagation();
                    if (lastHighlightedElement) lastHighlightedElement.style.outline = '';
                    selectedElement = e.target;
                    selectedElement.style.outline = '2px solid #007acc';
                    lastHighlightedElement = selectedElement;
                    lastSelectedSelectorPath = getCssSelector(selectedElement);
                    populateInspector(selectedElement);
                }, { capture: true });
            }
            function restoreSelection() {
                if (!lastSelectedSelectorPath) return false;
                const iframe = document.getElementById('preview-frame');
                const pdoc = iframe.contentDocument || iframe.contentWindow.document;
                if (!pdoc) return false;
                let el = null; try { el = pdoc.querySelector(lastSelectedSelectorPath); } catch (_) {}
                if (el) {
                    if (lastHighlightedElement) lastHighlightedElement.style.outline = '';
                    selectedElement = el;
                    selectedElement.style.outline = '2px solid #007acc';
                    lastHighlightedElement = selectedElement;
                    populateInspector(selectedElement);
                    return true;
                }
                return false;
            }
            function getCssSelector(el) {
                if (!el || el.nodeType !== 1) return '';
                const parts = [];
                while (el && el.nodeType === 1) {
                    let selector = el.nodeName.toLowerCase();
                    if (el.id) {
                        selector = '#' + el.id; parts.unshift(selector); break;
                    } else {
                        if (el.classList && el.classList.length) selector += '.' + el.classList[0];
                        let sib = el, nth = 1;
                        while (sib = sib.previousElementSibling) {
                            if (sib.nodeName.toLowerCase() === el.nodeName.toLowerCase()) nth++;
                        }
                        if (nth !== 1) selector += `:nth-of-type(${nth})`;
                    }
                    parts.unshift(selector);
                    el = el.parentNode;
                }
                return parts.join(' > ');
            }
            function showInspectorPlaceholder() {
                document.getElementById('inspector-placeholder').style.display = 'block';
                document.getElementById('inspector-ui').style.display = 'none';
            }
            function populateInspector(element) {
                document.getElementById('inspector-placeholder').style.display = 'none';
                document.getElementById('inspector-ui').style.display = 'block';
                const iframe = document.getElementById('preview-frame');
                const pwin = iframe.contentWindow;
                const styles = pwin.getComputedStyle(element);
                document.getElementById('selected-element-selector').textContent = getCssSelector(element);
                const textAsHTML = document.getElementById('inspector-text-as-html');
                textAsHTML.checked = false;
                document.getElementById('inspector-text').value = element.textContent ?? '';
                const colorInput = document.getElementById('inspector-color');
                const bgInput = document.getElementById('inspector-bg');
                colorInput.value = styles.color || '';
                bgInput.value = styles.backgroundColor || '';
                updateColorUI('color'); updateColorUI('bg'); updateApplyButtons(); updateHistoryButtons();
                document.getElementById('inspector-padding').value = styles.padding || '';
                document.getElementById('inspector-margin').value = styles.margin || '';
                document.getElementById('inspector-fontSize').value = styles.fontSize || '';
            }

            function applyStyleChange(property, value) {
                if (!selectedElement) return;
                selectedElement.style[property] = value;
                const selector = getCssSelector(selectedElement);
                let cssCode = cssEditor.getValue();
                const cssProperty = property.replace(/([A-Z])/g, '-$1').toLowerCase();
                const esc = selector.replace(/[\/\\^$*+?.()|[\]{}]/g, '\\$&');
                const regex = new RegExp(`(${esc})\\s*\\{([^}]*)\\}`, 's');
                const match = cssCode.match(regex);
                if (match) {
                    let properties = match[2];
                    const propRegex = new RegExp(`(^|;)\\s*${cssProperty}\\s*:[^;]*`, 'i');
                    if (propRegex.test(properties)) {
                        const newProperties = properties.replace(propRegex, `$1 ${cssProperty}: ${value}`);
                        cssCode = cssCode.replace(match[0], `${selector} {${newProperties}}`);
                    } else {
                        const trimmed = properties.trim();
                        const sep = trimmed && !trimmed.endsWith(';') ? ';' : '';
                        const newProperties = `${trimmed}${sep} ${cssProperty}: ${value}; `;
                        cssCode = cssCode.replace(match[0], `${selector} {\n${newProperties}\n}`);
                    }
                } else {
                    cssCode += `\n\n${selector} {\n    ${cssProperty}: ${value};\n}`;
                }
                lastSelectedSelectorPath = selector;
                cssEditor.setValue(cssCode);
            }

            // カラー入力 妥当性
            function isValidCSSColor(value) {
                const iframe = document.getElementById('preview-frame');
                const pwin = iframe.contentWindow;
                try {
                    if (pwin.CSS && typeof pwin.CSS.supports === 'function') {
                        return pwin.CSS.supports('color', value);
                    }
                } catch (_) { }
                const opt = pwin.document.createElement('option');
                opt.style.color = '';
                opt.style.color = value;
                return !!opt.style.color;
            }
            function updateColorUI(kind) {
                const input = document.getElementById(kind === 'color' ? 'inspector-color' : 'inspector-bg');
                const swatch = document.getElementById(kind === 'color' ? 'swatch-color' : 'swatch-bg');
                const badge = document.getElementById(kind === 'color' ? 'valid-color' : 'valid-bg');
                const val = input.value.trim();
                if (!val) { swatch.style.background = 'transparent'; badge.textContent = '未入力'; badge.classList.remove('ok','ng'); }
                else if (isValidCSSColor(val)) { swatch.style.background = val; badge.textContent = 'OK'; badge.classList.add('ok'); badge.classList.remove('ng'); }
                else { swatch.style.background = 'transparent'; badge.textContent = '不正'; badge.classList.add('ng'); badge.classList.remove('ok'); }
                updateApplyButtons();
            }
            function updateApplyButtons() {
                const colorVal = document.getElementById('inspector-color').value.trim();
                const bgVal = document.getElementById('inspector-bg').value.trim();
                document.getElementById('apply-color').disabled = !(selectedElement && isValidCSSColor(colorVal));
                document.getElementById('apply-bg').disabled = !(selectedElement && isValidCSSColor(bgVal));
            }
            function updateHistoryButtons() {
                const selector = lastSelectedSelectorPath;
                const entry = selector ? colorHistory.get(selector) : null;
                const canUndoColor = !!(entry && entry.color.undo.length);
                const canUndoBg = !!(entry && entry.backgroundColor.undo.length);
                const canRedoColor = !!(entry && entry.color.redo.length);
                const canRedoBg = !!(entry && entry.backgroundColor.redo.length);
                document.getElementById('undo-color').disabled = !canUndoColor;
                document.getElementById('undo-bg').disabled = !canUndoBg;
                document.getElementById('redo-color').disabled = !canRedoColor;
                document.getElementById('redo-bg').disabled = !canRedoBg;
            }

            document.getElementById('inspector-color').addEventListener('input', () => updateColorUI('color'));
            document.getElementById('inspector-bg').addEventListener('input', () => updateColorUI('bg'));
            document.getElementById('apply-color').addEventListener('click', () => commitColor('color'));
            document.getElementById('apply-bg').addEventListener('click', () => commitColor('backgroundColor'));
            document.getElementById('undo-color').addEventListener('click', () => undoColor('color'));
            document.getElementById('undo-bg').addEventListener('click', () => undoColor('backgroundColor'));
            document.getElementById('redo-color').addEventListener('click', () => redoColor('color'));
            document.getElementById('redo-bg').addEventListener('click', () => redoColor('backgroundColor'));

            function commitColor(prop) {
                if (!selectedElement) return;
                const input = document.getElementById(prop === 'color' ? 'inspector-color' : 'inspector-bg');
                const val = input.value.trim();
                if (!isValidCSSColor(val)) return;
                const selector = getCssSelector(selectedElement);
                lastSelectedSelectorPath = selector;
                const iframe = document.getElementById('preview-frame');
                const pwin = iframe.contentWindow;
                const styles = pwin.getComputedStyle(selectedElement);
                const prev = prop === 'color' ? styles.color : styles.backgroundColor;
                const h = getHistory(selector);
                h[prop].undo.push(prev);
                h[prop].redo.length = 0;
                updateHistoryButtons();
                applyStyleChange(prop, val);
            }
            function undoColor(prop) {
                const selector = lastSelectedSelectorPath;
                if (!selector) return;
                const h = colorHistory.get(selector);
                if (!h || !h[prop] || !h[prop].undo.length) return;
                const iframe = document.getElementById('preview-frame');
                const pwin = iframe.contentWindow;
                const styles = pwin.getComputedStyle(selectedElement);
                const currentVal = prop === 'color' ? styles.color : styles.backgroundColor;
                h[prop].redo.push(currentVal);
                const prev = h[prop].undo.pop();
                const input = document.getElementById(prop === 'color' ? 'inspector-color' : 'inspector-bg');
                input.value = prev || '';
                updateColorUI(prop === 'color' ? 'color' : 'bg');
                applyStyleChange(prop, prev);
                updateHistoryButtons();
            }
            function redoColor(prop) {
                const selector = lastSelectedSelectorPath;
                if (!selector) return;
                const h = colorHistory.get(selector);
                if (!h || !h[prop] || !h[prop].redo.length) return;
                const iframe = document.getElementById('preview-frame');
                const pwin = iframe.contentWindow;
                const styles = pwin.getComputedStyle(selectedElement);
                const currentVal = prop === 'color' ? styles.color : styles.backgroundColor;
                h[prop].undo.push(currentVal);
                const nextVal = h[prop].redo.pop();
                const input = document.getElementById(prop === 'color' ? 'inspector-color' : 'inspector-bg');
                input.value = nextVal || '';
                updateColorUI(prop === 'color' ? 'color' : 'bg');
                applyStyleChange(prop, nextVal);
                updateHistoryButtons();
            }

            // テキスト編集
            const textArea = document.getElementById('inspector-text');
            const textAsHTML = document.getElementById('inspector-text-as-html');
            const applyTextBtn = document.getElementById('apply-text');
            textAsHTML.addEventListener('change', () => {
                if (!selectedElement) return;
                textArea.value = textAsHTML.checked ? (selectedElement.innerHTML ?? '') : (selectedElement.textContent ?? '');
            });
            function toBodyRelativeSelector(sel) {
                return sel.replace(/^html\s*>\s*body\s*>\s*/i, '').replace(/^body\s*>\s*/i, '');
            }
            applyTextBtn.addEventListener('click', () => {
                if (!selectedElement) return;
                const selector = getCssSelector(selectedElement);
                lastSelectedSelectorPath = selector;
                const value = textArea.value ?? '';
                if (textAsHTML.checked) selectedElement.innerHTML = value; else selectedElement.textContent = value;
                const wrapper = document.createElement('div');
                wrapper.innerHTML = htmlEditor.getValue();
                let target = null;
                try { target = wrapper.querySelector(selector); } catch (_) {}
                if (!target) {
                    const rel = toBodyRelativeSelector(selector);
                    try { target = wrapper.querySelector(rel); } catch (_) {}
                }
                if (!target && selectedElement.id) {
                    try { target = wrapper.querySelector('#' + selectedElement.id); } catch (_) {}
                }
                if (target) {
                    if (textAsHTML.checked) target.innerHTML = value; else target.textContent = value;
                    htmlEditor.setValue(wrapper.innerHTML.trim());
                }
            });

            // ボックス系
            document.getElementById('inspector-padding').addEventListener('change', (e) => {
                const value = e.target.value.trim();
                if (value) { lastSelectedSelectorPath = selectedElement ? getCssSelector(selectedElement) : lastSelectedSelectorPath; applyStyleChange('padding', value); }
            });
            document.getElementById('inspector-margin').addEventListener('change', (e) => {
                const value = e.target.value.trim();
                if (value) { lastSelectedSelectorPath = selectedElement ? getCssSelector(selectedElement) : lastSelectedSelectorPath; applyStyleChange('margin', value); }
            });
            document.getElementById('inspector-fontSize').addEventListener('change', (e) => {
                const value = e.target.value.trim();
                if (value) { lastSelectedSelectorPath = selectedElement ? getCssSelector(selectedElement) : lastSelectedSelectorPath; applyStyleChange('fontSize', value); }
            });

            // --- 初期プレビュー描画 ---
            updatePreview();
            showMainTab('code');

            // ======================================
            // 画像カラー分析タブ（ボカシブラシ、タッチオフセット対応）
            // ======================================
            const MAX_IMAGES = 10;
            let images = []; // { id, img, sourceCanvas, sctx, drawnRect, history:[], currentColor:null, blurHistory:[], originalData:null }
            let activeIndex = -1;

            const stage = document.getElementById('image-stage');
            const displayCanvas = document.getElementById('image-canvas');
            const dctx = displayCanvas.getContext('2d');
            const magnifierCanvas = document.getElementById('magnifier-canvas');
            const mctx = magnifierCanvas.getContext('2d');
            mctx.imageSmoothingEnabled = false;

            const statusLine = document.getElementById('img-status');
            const stageHint = document.getElementById('stage-hint');
            const stageOverlay = document.getElementById('stage-overlay');
            const switcher = document.getElementById('img-switcher');

            const fileInput = document.getElementById('img-file');
            const urlInput = document.getElementById('img-url');
            const urlBtn = document.getElementById('btn-load-url');
            const eyedropBtn = document.getElementById('btn-eyedropper');
            const canvasPickerBtn = document.getElementById('btn-canvas-picker');
            const blurBrushBtn = document.getElementById('btn-blur-brush');
            const blurSettingsPanel = document.getElementById('blur-brush-settings');
            const brushSizeInput = document.getElementById('brush-size');
            const brushSizeDisplay = document.getElementById('brush-size-display');
            const blurStrengthInput = document.getElementById('blur-strength');
            const blurStrengthDisplay = document.getElementById('blur-strength-display');
            const undoBlurBtn = document.getElementById('btn-undo-blur');
            const resetBlurBtn = document.getElementById('btn-reset-blur');

            let toolMode = 'none'; // 'none', 'picker', 'blur'
            let isDrawing = false;
            let brushSize = 20;
            let blurStrength = 5;

            // タッチオフセット関連
            const touchOffsetEnabledCheck = document.getElementById('touch-offset-enabled');
            const touchOffsetValueInput = document.getElementById('touch-offset-value');
            let touchOffsetEnabled = true;
            let touchOffsetValue = 40;

            // ポインターマーカー、ブラシプレビュー、オフセットラインを動的に生成して追加
            const pointerMarker = document.createElement('div');
            pointerMarker.id = 'pointer-marker';
            stage.appendChild(pointerMarker);

            const brushPreview = document.createElement('div');
            brushPreview.id = 'brush-preview';
            stage.appendChild(brushPreview);

            const offsetLine = document.createElement('div');
            offsetLine.id = 'offset-line';
            stage.appendChild(offsetLine);

            const historyContainer = document.getElementById('history-list');
            const currentSwatch = document.getElementById('current-swatch');
            const currentColorText = document.getElementById('current-color-text');

            const outHex = document.getElementById('hex-val');
            const outHexa = document.getElementById('hexa-val');
            const outRgb = document.getElementById('rgb-val');
            const outHsl = document.getElementById('hsl-val');
            const outLum = document.getElementById('luminance-val');
            const outContB = document.getElementById('contrast-black');
            const outContW = document.getElementById('contrast-white');
            const sampleOnBlack = document.getElementById('contrast-on-black');
            const sampleOnWhite = document.getElementById('contrast-on-white');

            function setStatus(msg) { statusLine.textContent = msg || ''; }

            function enableEyedropperUI() {
                if (!('EyeDropper' in window)) {
                    eyedropBtn.disabled = true;
                    eyedropBtn.title = 'このブラウザは画面スポイトに未対応です';
                }
            }
            enableEyedropperUI();

            function addImageFromHTMLImageElement(img) {
                if (images.length >= MAX_IMAGES) {
                    setStatus(`これ以上追加できません（最大${MAX_IMAGES}枚）`);
                    return;
                }
                const sourceCanvas = document.createElement('canvas');
                const sctx = sourceCanvas.getContext('2d', { willReadFrequently: true });
                sctx.imageSmoothingEnabled = false;
                const iw = img.naturalWidth || img.width;
                const ih = img.naturalHeight || img.height;
                sourceCanvas.width = iw;
                sourceCanvas.height = ih;
                sctx.clearRect(0,0,iw,ih);
                sctx.drawImage(img, 0, 0);

                const id = images.length + 1;
                const originalData = sctx.getImageData(0, 0, iw, ih);
                const item = { id, img, sourceCanvas, sctx, drawnRect: {dx:0,dy:0,dw:0,dh:0}, history: [], currentColor: null, blurHistory: [], originalData };
                images.push(item);
                renderImageButtons();
                setActiveImage(images.length - 1);
                setStatus(`画像${id} を追加しました（${iw}×${ih}）`);
            }

            function renderImageButtons() {
                switcher.innerHTML = '';
                images.forEach((it, i) => {
                    const btn = document.createElement('button');
                    btn.className = 'img-chip' + (i === activeIndex ? ' active' : '');
                    btn.textContent = `画像${it.id}`;
                    btn.addEventListener('click', () => setActiveImage(i));
                    switcher.appendChild(btn);
                });
            }

            function setActiveImage(index) {
                if (index < 0 || index >= images.length) return;
                activeIndex = index;
                renderImageButtons();
                stageHint.style.display = 'none';
                resizeImageStage();
                const act = getActiveImage();
                if (act) {
                    if (act.currentColor) setCurrentColor(act.currentColor, false);
                    else resetColorOutputs();
                    updateBlurButtons();
                }
                renderHistory();
                setStatus(`画像${act.id} を表示中`);
            }

            function getActiveImage() {
                if (activeIndex < 0 || activeIndex >= images.length) return null;
                return images[activeIndex];
            }

            function loadImageFromFile(file) {
                if (!file || !file.type || !file.type.startsWith('image/')) {
                    setStatus('画像ファイルを選択してください');
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => loadImageFromSrc(e.target.result, false);
                reader.readAsDataURL(file);
            }

            function loadImageFromSrc(src, remote) {
                const img = new Image();
                if (remote) img.crossOrigin = 'anonymous';
                img.onload = () => addImageFromHTMLImageElement(img);
                img.onerror = () => setStatus('画像を読み込めませんでした（URLの誤りやCORS制限の可能性があります）');
                img.src = src;
            }

            function resizeImageStage() {
                const rect = stage.getBoundingClientRect();
                const w = Math.max(10, Math.floor(rect.width));
                const h = Math.max(10, Math.floor(rect.height));
                if (displayCanvas.width !== w || displayCanvas.height !== h) {
                    displayCanvas.width = w;
                    displayCanvas.height = h;
                }
                redrawDisplay();
            }
            window.resizeImageStage = resizeImageStage;

            function redrawDisplay() {
                dctx.clearRect(0,0,displayCanvas.width, displayCanvas.height);
                const act = getActiveImage();
                if (!act) return;
                const img = act.sourceCanvas; // ぼかしを反映するため、imgではなくsourceCanvasから描画
                const iw = img.width;
                const ih = img.height;
                const sw = displayCanvas.width;
                const sh = displayCanvas.height;
                const scale = Math.min(sw/iw, sh/ih);
                const dw = Math.max(1, Math.floor(iw * scale));
                const dh = Math.max(1, Math.floor(ih * scale));
                const dx = Math.floor((sw - dw)/2);
                const dy = Math.floor((sh - dh)/2);
                act.drawnRect = { dx, dy, dw, dh };
                dctx.imageSmoothingEnabled = true;
                dctx.drawImage(img, dx, dy, dw, dh);
            }

            function mapToImagePixel(clientX, clientY) {
                const act = getActiveImage();
                if (!act) return null;
                const rect = displayCanvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                const { dx, dy, dw, dh } = act.drawnRect || {dx:0,dy:0,dw:0,dh:0};
                if (x < dx || y < dy || x >= dx + dw || y >= dy + dh) return null;
                const nx = (x - dx) / dw;
                const ny = (y - dy) / dh;
                const px = Math.max(0, Math.min(act.sourceCanvas.width - 1, Math.floor(nx * act.sourceCanvas.width)));
                const py = Math.max(0, Math.min(act.sourceCanvas.height - 1, Math.floor(ny * act.sourceCanvas.height)));
                return { px, py, cx: x, cy: y };
            }

            function readPixel(px, py) {
                const act = getActiveImage();
                if (!act) return null;
                try {
                    const data = act.sctx.getImageData(px, py, 1, 1).data;
                    return { r: data[0], g: data[1], b: data[2], a: data[3] / 255 };
                } catch (e) {
                    setStatus('キャンバスからの読み取りに失敗しました（CORS制限の可能性）');
                    return null;
                }
            }

            function drawMagnifier(px, py, cx, cy) {
                const act = getActiveImage();
                if (!act) return;
                const w = magnifierCanvas.width;
                const h = magnifierCanvas.height;
                const size = 21;
                const half = Math.floor(size / 2);
                const sx = Math.max(0, Math.min(act.sourceCanvas.width - size, px - half));
                const sy = Math.max(0, Math.min(act.sourceCanvas.height - size, py - half));
                mctx.clearRect(0,0,w,h);
                mctx.imageSmoothingEnabled = false;
                mctx.fillStyle = '#222'; mctx.fillRect(0,0,w,h);
                mctx.drawImage(act.sourceCanvas, sx, sy, size, size, 0, 0, w, h);

                mctx.strokeStyle = 'rgba(255,255,255,0.2)';
                mctx.lineWidth = 1;
                const step = w / size;
                for (let i = 1; i < size; i++) {
                    mctx.beginPath(); mctx.moveTo(i*step, 0); mctx.lineTo(i*step, h); mctx.stroke();
                    mctx.beginPath(); mctx.moveTo(0, i*step); mctx.lineTo(w, i*step); mctx.stroke();
                }
                mctx.strokeStyle = '#fff';
                mctx.lineWidth = 2;
                const cxLine = Math.floor(w/2) + 0.5;
                const cyLine = Math.floor(h/2) + 0.5;
                mctx.beginPath(); mctx.moveTo(cxLine, 0); mctx.lineTo(cxLine, h); mctx.stroke();
                mctx.beginPath(); mctx.moveTo(0, cyLine); mctx.lineTo(w, cyLine); mctx.stroke();

                const rect = stage.getBoundingClientRect();
                const left = Math.min(rect.width - w - 10, Math.max(10, cx + 20));
                const top  = Math.min(rect.height - h - 10, Math.max(10, cy + 20));
                magnifierCanvas.style.left = left + 'px';
                magnifierCanvas.style.top  = top + 'px';
                magnifierCanvas.style.display = 'block';
            }

            function hideMagnifier() { magnifierCanvas.style.display = 'none'; }

            function setToolMode(mode) {
                if (toolMode === mode) {
                    toolMode = 'none';
                } else {
                    toolMode = mode;
                }
                stage.classList.toggle('picking', toolMode === 'picker');
                stage.classList.toggle('blurring', toolMode === 'blur');
                blurSettingsPanel.style.display = toolMode === 'blur' ? 'flex' : 'none';

                canvasPickerBtn.classList.toggle('active', toolMode === 'picker');
                blurBrushBtn.classList.toggle('active', toolMode === 'blur');

                if (toolMode === 'picker') {
                    setStatus('キャンバススポイト: クリックで色を取得');
                } else if (toolMode === 'blur') {
                    setStatus('ボカシブラシ: ドラッグでぼかす');
                } else {
                    setStatus('');
                    hideMagnifier();
                }
            }

            function resetColorOutputs() {
                currentSwatch.style.background = '#000';
                currentColorText.textContent = '未取得';
                outHex.textContent = '-'; outHexa.textContent = '-'; outRgb.textContent = '-'; outHsl.textContent = '-';
                outLum.textContent = '-'; outContB.textContent = '-'; outContW.textContent = '-';
                sampleOnBlack.style.color = '#fff'; sampleOnWhite.style.color = '#000';
            }

            function setCurrentColor(col, pushHistory = false) {
                if (!col) return;
                const { r, g, b, a } = col;
                const hex = rgbToHex(r,g,b);
                const hexa = rgbaToHex(r,g,b,a);
                const rgb = toRgbString(r,g,b,a);
                const hsl = toHslString(r,g,b,a);
                const lum = relativeLuminance(r,g,b);
                const contB = contrastRatio(lum, 0);
                const contW = contrastRatio(1, lum);

                currentSwatch.style.background = hexa;
                currentColorText.textContent = `${hex} / ${rgb}`;
                outHex.textContent = hex; outHexa.textContent = hexa; outRgb.textContent = rgb; outHsl.textContent = hsl;
                outLum.textContent = lum.toFixed(4); outContB.textContent = contB.toFixed(2); outContW.textContent = contW.toFixed(2);
                sampleOnBlack.style.color = hexa; sampleOnWhite.style.color = hexa;

                const act = getActiveImage();
                if (act) {
                    act.currentColor = { r, g, b, a };
                    if (pushHistory) {
                        act.history.unshift({ r, g, b, a });
                        if (act.history.length > 60) act.history.pop();
                        renderHistory();
                    }
                }
            }

            function renderHistory() {
                historyContainer.innerHTML = '';
                const act = getActiveImage();
                if (!act || !act.history.length) return;
                act.history.forEach((c) => {
                    const d = document.createElement('button');
                    d.className = 'history-item';
                    d.style.background = rgbaToHex(c.r, c.g, c.b, c.a);
                    d.title = rgbToHex(c.r, c.g, c.b);
                    d.addEventListener('click', () => setCurrentColor(c, false));
                    historyContainer.appendChild(d);
                });
            }

            // 新機能：タッチオフセットとマーカーのロジック
            function adjustPointerPosition(clientX, clientY, isTouch) {
                let adjustedX = clientX;
                let adjustedY = clientY;
                const rect = stage.getBoundingClientRect();

                if (isTouch && touchOffsetEnabled && touchOffsetValue > 0) {
                    adjustedY = clientY - touchOffsetValue;
                    offsetLine.style.left = (clientX - rect.left) + 'px';
                    offsetLine.style.top = (adjustedY - rect.top) + 'px';
                    offsetLine.style.height = touchOffsetValue + 'px';
                    offsetLine.style.display = 'block';
                } else {
                    offsetLine.style.display = 'none';
                }
                return { x: adjustedX, y: adjustedY };
            }

            function updatePointerMarker(clientX, clientY, show) {
                if (!show) {
                    pointerMarker.style.display = 'none';
                    return;
                }
                const rect = stage.getBoundingClientRect();
                pointerMarker.style.left = (clientX - rect.left) + 'px';
                pointerMarker.style.top = (clientY - rect.top) + 'px';
                pointerMarker.style.display = 'block';
            }

            function updateBrushPreview(clientX, clientY, show) {
                if (!show || toolMode !== 'blur') {
                    brushPreview.style.display = 'none';
                    return;
                }
                const rect = stage.getBoundingClientRect();
                const size = brushSize * 2;
                brushPreview.style.width = size + 'px';
                brushPreview.style.height = size + 'px';
                brushPreview.style.left = (clientX - rect.left) + 'px';
                brushPreview.style.top = (clientY - rect.top) + 'px';
                brushPreview.style.display = 'block';
            }

            // 新機能：ボカシ処理
            function applyBlur(px, py) {
                const act = getActiveImage();
                if (!act) return;

                // 処理範囲を計算
                const radius = Math.floor(brushSize / 2);
                const sx = Math.max(0, px - radius);
                const sy = Math.max(0, py - radius);
                const ex = Math.min(act.sourceCanvas.width, px + radius);
                const ey = Math.min(act.sourceCanvas.height, py + radius);
                const sw = ex - sx;
                const sh = ey - sy;

                if (sw <= 0 || sh <= 0) return;

                const imageData = act.sctx.getImageData(sx, sy, sw, sh);
                const data = imageData.data;
                const output = new Uint8ClampedArray(data);

                // ボックスブラー（簡易）
                for (let pass = 0; pass < blurStrength; pass++) {
                    for (let y = 0; y < sh; y++) {
                        for (let x = 0; x < sw; x++) {
                            let r = 0, g = 0, b = 0, count = 0;
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < sw && ny >= 0 && ny < sh) {
                                        const nIdx = (ny * sw + nx) * 4;
                                        r += data[nIdx];
                                        g += data[nIdx + 1];
                                        b += data[nIdx + 2];
                                        count++;
                                    }
                                }
                            }
                            const idx = (y * sw + x) * 4;
                            output[idx] = r / count;
                            output[idx + 1] = g / count;
                            output[idx + 2] = b / count;
                        }
                    }
                    data.set(output);
                }

                act.sctx.putImageData(imageData, sx, sy);
                redrawDisplay();
            }

            function updateBlurButtons() {
                const act = getActiveImage();
                undoBlurBtn.disabled = !(act && act.blurHistory.length > 0);
                resetBlurBtn.disabled = !(act && act.blurHistory.length > 0);
            }

            // 統合ポインターイベントハンドラ
            function handlePointerStart(clientX, clientY, isTouch) {
                const { x, y } = adjustPointerPosition(clientX, clientY, isTouch);
                updatePointerMarker(x, y, toolMode !== 'none');

                if (toolMode === 'picker') {
                    const map = mapToImagePixel(x, y);
                    if (map) {
                        const pix = readPixel(map.px, map.py);
                        if (pix) {
                            setCurrentColor(pix, true);
                            setStatus('色を取得しました');
                        }
                    }
                } else if (toolMode === 'blur') {
                    isDrawing = true;
                    const act = getActiveImage();
                    if (act) {
                        // Undo用に現在の状態を保存
                        act.blurHistory.push(act.sctx.getImageData(0, 0, act.sourceCanvas.width, act.sourceCanvas.height));
                        updateBlurButtons();
                        const map = mapToImagePixel(x, y);
                        if (map) applyBlur(map.px, map.py);
                    }
                }
            }

            function handlePointerMove(clientX, clientY, isTouch) {
                const { x, y } = adjustPointerPosition(clientX, clientY, isTouch);
                updatePointerMarker(x, y, toolMode !== 'none');
                updateBrushPreview(x, y, toolMode === 'blur');

                if (toolMode === 'picker') {
                    const map = mapToImagePixel(x, y);
                    if (map) {
                        const pix = readPixel(map.px, map.py);
                        if (pix) drawMagnifier(map.px, map.py, map.cx, map.cy);
                    } else {
                        hideMagnifier();
                    }
                } else if (toolMode === 'blur' && isDrawing) {
                    const map = mapToImagePixel(x, y);
                    if (map) applyBlur(map.px, map.py);
                }
            }

            function handlePointerEnd() {
                isDrawing = false;
                pointerMarker.style.display = 'none';
                offsetLine.style.display = 'none';
                brushPreview.style.display = 'none';
            }

            // 画像入力（複数同時）
            fileInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files || []);
                if (!files.length) return;
                const room = MAX_IMAGES - images.length;
                files.slice(0, room).forEach(loadImageFromFile);
                if (files.length > room) setStatus(`最大${MAX_IMAGES}枚までです。超過分は読み込みませんでした。`);
                fileInput.value = '';
            });
            urlBtn.addEventListener('click', () => {
                const url = urlInput.value.trim();
                if (!url) { setStatus('画像URLを入力してください'); return; }
                if (images.length >= MAX_IMAGES) { setStatus(`最大${MAX_IMAGES}枚までです`); return; }
                loadImageFromSrc(url, true);
            });

            // D&D 複数対応
            stage.addEventListener('dragover', (e) => { e.preventDefault(); stageOverlay.style.display = 'block'; });
            stage.addEventListener('dragleave', () => { stageOverlay.style.display = toolMode === 'none' ? 'none' : 'block'; });
            stage.addEventListener('drop', (e) => {
                e.preventDefault();
                stageOverlay.style.display = toolMode === 'none' ? 'none' : 'block';
                const files = Array.from(e.dataTransfer.files || []).filter(f => f.type && f.type.startsWith('image/'));
                if (!files.length) return;
                const room = MAX_IMAGES - images.length;
                files.slice(0, room).forEach(loadImageFromFile);
                if (files.length > room) setStatus(`最大${MAX_IMAGES}枚までです。超過分は読み込みませんでした。`);
            });

            // ツールボタン
            eyedropBtn.addEventListener('click', async () => {
                setToolMode('none');
                if (!('EyeDropper' in window)) return;
                try {
                    const ed = new window.EyeDropper();
                    const res = await ed.open();
                    const col = hexToRgba(res.sRGBHex);
                    setCurrentColor(col, true);
                    setStatus('画面スポイトで色を取得しました');
                } catch {
                    setStatus('画面スポイトをキャンセルしました');
                }
            });
            canvasPickerBtn.addEventListener('click', () => setToolMode('picker'));
            blurBrushBtn.addEventListener('click', () => setToolMode('blur'));

            // ボカシブラシ設定
            brushSizeInput.addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value, 10);
                brushSizeDisplay.textContent = brushSize;
            });
            blurStrengthInput.addEventListener('input', (e) => {
                blurStrength = parseInt(e.target.value, 10);
                blurStrengthDisplay.textContent = blurStrength;
            });
            undoBlurBtn.addEventListener('click', () => {
                const act = getActiveImage();
                if (!act || act.blurHistory.length === 0) return;
                const lastState = act.blurHistory.pop();
                act.sctx.putImageData(lastState, 0, 0);
                redrawDisplay();
                updateBlurButtons();
                setStatus('ボカシを元に戻しました');
            });
            resetBlurBtn.addEventListener('click', () => {
                const act = getActiveImage();
                if (!act || !act.originalData) return;
                act.sctx.putImageData(act.originalData, 0, 0);
                act.blurHistory = [];
                redrawDisplay();
                updateBlurButtons();
                setStatus('ボカシをリセットしました');
            });

            // タッチオフセット設定
            touchOffsetEnabledCheck.addEventListener('change', (e) => { touchOffsetEnabled = e.target.checked; });
            touchOffsetValueInput.addEventListener('change', (e) => { touchOffsetValue = parseInt(e.target.value, 10) || 0; });

            // ポインターイベント
            displayCanvas.addEventListener('mousedown', e => handlePointerStart(e.clientX, e.clientY, false));
            displayCanvas.addEventListener('mousemove', e => handlePointerMove(e.clientX, e.clientY, false));
            displayCanvas.addEventListener('mouseup', handlePointerEnd);
            displayCanvas.addEventListener('mouseleave', handlePointerEnd);
            displayCanvas.addEventListener('touchstart', e => { if (e.touches.length === 1) { e.preventDefault(); handlePointerStart(e.touches[0].clientX, e.touches[0].clientY, true); }}, { passive: false });
            displayCanvas.addEventListener('touchmove', e => { if (e.touches.length === 1) { e.preventDefault(); handlePointerMove(e.touches[0].clientX, e.touches[0].clientY, true); }}, { passive: false });
            displayCanvas.addEventListener('touchend', handlePointerEnd);

            // リサイズ追従
            const ro = new ResizeObserver(() => resizeImageStage());
            ro.observe(stage);

            // コピー
            document.querySelectorAll('.copy-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const id = btn.getAttribute('data-copy-target');
                    const el = document.getElementById(id);
                    if (!el) return;
                    try {
                        await navigator.clipboard.writeText(el.textContent.trim());
                        setStatus('クリップボードにコピーしました');
                    } catch {
                        setStatus('コピーに失敗しました');
                    }
                });
            });

            // 初期文言
            setStatus('画像を読み込むとスポイトやブラシが使えます');

            // ===========
            // 色変換系
            // ===========
            function clamp01(x){ return Math.min(1, Math.max(0, x)); }
            function pad2(n){ return n.toString(16).padStart(2, '0').toUpperCase(); }

            function rgbToHex(r,g,b){ return '#' + pad2(r) + pad2(g) + pad2(b); }
            function rgbaToHex(r,g,b,a=1){
                const aa = Math.round(clamp01(a) * 255);
                return '#' + pad2(r) + pad2(g) + pad2(b) + pad2(aa);
            }
            function hexToRgba(hex){
                let h = hex.replace('#','').trim();
                if (h.length === 3) {
                    const r = parseInt(h[0]+h[0],16), g = parseInt(h[1]+h[1],16), b = parseInt(h[2]+h[2],16);
                    return { r, g, b, a: 1 };
                } else if (h.length === 6) {
                    const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16);
                    return { r, g, b, a: 1 };
                } else if (h.length === 8) {
                    const r = parseInt(h.slice(0,2),16), g = parseInt(h.slice(2,4),16), b = parseInt(h.slice(4,6),16), a = parseInt(h.slice(6,8),16)/255;
                    return { r, g, b, a };
                }
                return { r:0,g:0,b:0,a:1 };
            }
            function toRgbString(r,g,b,a=1){
                const aa = clamp01(a);
                if (aa < 1) return `rgb(${r} ${g} ${b} / ${+(aa*100).toFixed(1)}%)`;
                return `rgb(${r} ${g} ${b})`;
            }
            function toHslString(r,g,b,a=1){
                const R = r/255, G = g/255, B = b/255;
                const max = Math.max(R,G,B), min = Math.min(R,G,B);
                let h=0, s, l = (max+min)/2;
                if (max === min) { s = 0; }
                else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case R: h = (G - B) / d + (G < B ? 6 : 0); break;
                        case G: h = (B - R) / d + 2; break;
                        case B: h = (R - G) / d + 4; break;
                    }
                    h /= 6;
                }
                const hh = Math.round((h*360) % 360);
                const ss = Math.round(s*100);
                const ll = Math.round(l*100);
                const aa = clamp01(a);
                if (aa < 1) return `hsl(${hh} ${ss}% ${ll}% / ${+(aa*100).toFixed(1)}%)`;
                return `hsl(${hh} ${ss}% ${ll}%)`;
            }
            function srgbToLinear(c){
                c /= 255;
                return c <= 0.04045 ? c/12.92 : Math.pow((c+0.055)/1.055, 2.4);
            }
            function relativeLuminance(r,g,b){
                const R = srgbToLinear(r), G = srgbToLinear(g), B = srgbToLinear(b);
                return 0.2126*R + 0.7152*G + 0.0722*B;
            }
            function contrastRatio(l1, l2){
                const L1 = Math.max(l1,l2), L2 = Math.min(l1,l2);
                return (L1 + 0.05) / (L2 + 0.05);
            }
        });
    </script>
</body>
</html>
